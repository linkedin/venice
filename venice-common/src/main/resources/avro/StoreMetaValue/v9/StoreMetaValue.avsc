{
  "name": "StoreMetaValue",
  "namespace": "com.linkedin.venice.systemstore.schemas",
  "type": "record",
  "fields": [
    {
      "name": "timestamp",
      "doc": "Timestamp when the value or a partial update for the value was generated by the writer (Venice Controller/Venice Server).",
      "type": "long",
      "default": 0
    },
    {
      "name": "storeProperties",
      "type": [
        "null",
        {
          "name": "StoreProperties",
          "doc": "This type contains all the store configs and the corresponding versions",
          "type": "record",
          "fields": [
            {"name": "name", "type": "string", "doc": "Store name."},
            {"name": "owner", "type": "string", "doc": "Owner of this store."},
            {"name": "createdTime", "type": "long", "doc": "Timestamp when this store was created."},
            {"name": "currentVersion", "type": "int", "default": 0, "doc": "The number of version which is used currently."},
            {"name": "partitionCount", "type": "int", "default": 0, "doc": "Default partition count for all of versions in this store. Once first version become online, the number will be assigned."},
            {"name":  "lowWatermark", "type": "long", "default": 0, "doc": "EOIP control message timestamp of the most recent incremental push that has been marked successful"},
            {"name": "enableWrites", "type": "boolean", "default": true, "doc": "If a store is disabled from writing, new version can not be created for it."},
            {"name": "enableReads", "type": "boolean", "default": true, "doc": "If a store is disabled from being read, none of versions under this store could serve read requests."},
            {"name": "storageQuotaInByte", "type": "long", "default": 21474836480, "doc": "Maximum capacity a store version is able to have, and default is 20GB"},
            {"name": "persistenceType", "type": "int", "default": 2, "doc": "Type of persistence storage engine, and default is 'ROCKS_DB'"},
            {"name": "routingStrategy", "type": "int", "default": 0, "doc": "How to route the key to partition, and default is 'CONSISTENT_HASH'"},
            {"name": "readStrategy", "type": "int", "default": 0, "doc": "How to read data from multiple replications, and default is 'ANY_OF_ONLINE'"},
            {"name": "offlinePushStrategy", "type": "int", "default": 1, "doc": "When doing off-line push, how to decide the data is ready to serve, and default is 'WAIT_N_MINUS_ONE_REPLCIA_PER_PARTITION'"},
            {"name": "largestUsedVersionNumber", "type": "int", "default": 0, "doc": "The largest version number ever used before for this store."},
            {"name": "readQuotaInCU", "type": "long", "default": 0, "doc": "Quota for read request hit this store. Measurement is capacity unit."},
            {
              "name": "hybridConfig",
              "doc": "Properties related to Hybrid Store behavior. If absent (null), then the store is not hybrid.",
              "type": [
                "null",
                {
                  "name": "StoreHybridConfig",
                  "type": "record",
                  "fields": [
                    {"name": "rewindTimeInSeconds", "type": "long"},
                    {"name": "offsetLagThresholdToGoOnline", "type": "long"},
                    {"name": "producerTimestampLagThresholdToGoOnlineInSeconds", "type": "long"},
                    {"name": "dataReplicationPolicy", "type": "int", "default": 0, "doc": "Real-time Samza job data replication policy, and default is 'NON_AGGREGATE'"},
                    {
                      "name": "bufferReplayPolicy",
                      "type": "int",
                      "doc": "Policy that will be used during buffer replay. rewindTimeInSeconds defines the delta. 0 => REWIND_FROM_EOP (replay from 'EOP - rewindTimeInSeconds'), 1 => REWIND_FROM_SOP (replay from 'SOP - rewindTimeInSeconds')",
                      "default": 0
                    }
                  ]
                }
              ],
              "default": null
            },
            {"name": "accessControlled", "type": "boolean", "default": true, "doc": "Store-level ACL switch. When disabled, Venice Router should accept every request."},
            {"name": "compressionStrategy", "type": "int", "default": 0, "doc": "Strategy used to compress/decompress Record's value, and default is 'NO_OP'"},
            {"name": "clientDecompressionEnabled", "type": "boolean", "default": true, "doc": "le/Disable client-side record decompression (default: true)"},
            {"name": "chunkingEnabled", "type": "boolean", "default": false, "doc": "Whether current store supports large value (typically more than 1MB). By default, the chunking feature is disabled."},
            {"name": "batchGetLimit", "type": "int", "default": -1, "doc": "Batch get key number limit, and Venice will use cluster-level config if it is not positive."},
            {"name": "numVersionsToPreserve", "type": "int", "default": 0, "doc": "How many versions this store preserve at most. By default it's 0 means we use the cluster level config to determine how many version is preserved."},
            {"name": "incrementalPushEnabled", "type": "boolean", "default": false, "doc": "Flag to see if the store supports incremental push or not"},
            {"name": "migrating", "type": "boolean", "default": false, "doc": "Whether or not the store is in the process of migration."},
            {"name": "writeComputationEnabled", "type": "boolean", "default": false, "doc": "Whether or not write-path computation feature is enabled for this store."},
            {"name": "readComputationEnabled", "type": "boolean", "default": false, "doc": "Whether read-path computation is enabled for this store."},
            {"name": "bootstrapToOnlineTimeoutInHours", "type": "int", "default": 24, "doc": "Maximum number of hours allowed for the store to transition from bootstrap to online state."},
            {"name": "leaderFollowerModelEnabled", "type": "boolean", "default": false, "doc": "Whether or not to use leader follower state transition model for upcoming version."},
            {"name": "nativeReplicationEnabled", "type": "boolean", "default": false, "doc": "Whether or not native should be enabled for this store.  Will only successfully apply if leaderFollowerModelEnabled is also true either in this update or a previous version of the store."},
            {"name": "pushStreamSourceAddress", "type": "string", "default": "", "doc": "Address to the kafka broker which holds the source of truth topic for this store version."},
            {"name": "backupStrategy", "type": "int", "default": 1, "doc": "Strategies to store backup versions, and default is 'DELETE_ON_NEW_PUSH_START'"},
            {"name": "schemaAutoRegisteFromPushJobEnabled", "type": "boolean", "default": false, "doc": "Whether or not value schema auto registration enabled from push job for this store."},
            {"name": "latestSuperSetValueSchemaId", "type": "int", "default": -1, "doc": "For read compute stores with auto super-set schema enabled, stores the latest super-set value schema ID."},
            {"name": "hybridStoreDiskQuotaEnabled", "type": "boolean", "default": false, "doc": "Whether or not storage disk quota is enabled for a hybrid store. This store config cannot be enabled until the routers and servers in the corresponding cluster are upgraded to the right version: 0.2.249 or above for routers and servers."},
            {"name": "storeMetadataSystemStoreEnabled", "type": "boolean", "default": false, "doc": "Whether or not the store metadata system store is enabled for this store."},
            {
              "name": "etlConfig",
              "doc": "Properties related to ETL Store behavior.",
              "type": [
                "null",
                {
                  "name": "StoreETLConfig",
                  "type": "record",
                  "fields": [
                    {"name": "etledUserProxyAccount", "type": "string", "doc": "If enabled regular ETL or future version ETL, this account name is part of path for where the ETLed snapshots will go. for example, for user account veniceetl001, snapshots will be published to HDFS /jobs/veniceetl001/storeName."},
                    {"name": "regularVersionETLEnabled", "type": "boolean", "doc": "Whether or not enable regular version ETL for this store."},
                    {"name": "futureVersionETLEnabled", "type": "boolean", "doc": "Whether or not enable future version ETL - the version that might come online in future - for this store."}
                  ]
                }
              ],
              "default": null
            },
            {
              "name": "partitionerConfig",
              "doc": "",
              "type": [
                "null",
                {
                  "name": "StorePartitionerConfig",
                  "type": "record",
                  "fields": [
                    {"name": "partitionerClass", "type": "string"},
                    {"name": "partitionerParams", "type": {"type": "map", "values": "string"}},
                    {"name": "amplificationFactor", "type": "int"}
                  ]
                }
              ],
              "default": null
            },
            {"name": "incrementalPushPolicy", "type": "int", "default": 0, "doc": "Incremental Push Policy to reconcile with real time pushes, and default is 'PUSH_TO_VERSION_TOPIC'"},
            {"name": "latestVersionPromoteToCurrentTimestamp", "type": "long", "default": -1, "doc": "This is used to track the time when a new version is promoted to current version. For now, it is mostly to decide whether a backup version can be removed or not based on retention. For the existing store before this code change, it will be set to be current timestamp."},
            {"name": "backupVersionRetentionMs", "type": "long", "default": -1, "doc": "Backup retention time, and if it is not set (-1), Venice Controller will use the default configured retention. {@link com.linkedin.venice.ConfigKeys#CONTROLLER_BACKUP_VERSION_DEFAULT_RETENTION_MS}."},
            {"name": "replicationFactor", "type": "int", "default": 3, "doc": "The number of replica each store version will keep."},
            {"name": "migrationDuplicateStore", "type": "boolean", "default": false, "doc": "Whether or not the store is a duplicate store in the process of migration."},
            {"name": "nativeReplicationSourceFabric", "type": "string", "default": "", "doc": "The source fabric name to be uses in native replication. Remote consumption will happen from kafka in this fabric."},
            {"name": "daVinciPushStatusStoreEnabled", "type": "boolean", "default": false, "doc": "Whether or not davinci push status store is enabled."},
            {"name": "storeMetaSystemStoreEnabled", "type": "boolean", "default": false, "doc": "Whether or not the store meta system store is enabled for this store."},
            {"name": "activeActiveReplicationEnabled", "type": "boolean", "default": false, "doc": "Whether or not active/active replication is enabled for hybrid stores; eventually this config will replace native replication flag, when all stores are on A/A"},
            {"name": "applyTargetVersionFilterForIncPush", "type": "boolean", "default": false, "doc": "Whether or not the target version field in Kafka messages will be used in increment push to RT policy"},
            {
              "name": "versions",
              "doc": "List of non-retired versions. It's currently sorted and there is code run under the assumption that the last element in the list is the largest. Check out {VeniceHelixAdmin#getIncrementalPushVersion}, and please make it in mind if you want to change this logic",
              "type": {
                "type": "array",
                "items": {
                  "name": "StoreVersion",
                  "type": "record",
                  "doc": "Type describes all the version attributes",
                  "fields": [
                    {"name": "storeName", "type": "string", "doc": "Name of the store which this version belong to."},
                    {"name": "number", "type": "int", "doc": "Version number."},
                    {"name": "createdTime", "type": "long", "doc": "Time when this version was created."},
                    {"name": "status", "type": "int", "default": 1, "doc": "Status of version, and default is 'STARTED'"},
                    {"name": "pushJobId", "type": "string", "default": ""},
                    {"name": "compressionStrategy", "type": "int", "default": 0, "doc": "strategies used to compress/decompress Record's value, and default is 'NO_OP'"},
                    {"name": "leaderFollowerModelEnabled", "type": "boolean", "default": false, "doc": "Whether or not to use leader follower state transition."},
                    {"name": "nativeReplicationEnabled", "type": "boolean", "default": false, "doc": "Whether or not native replication is enabled."},
                    {"name": "pushStreamSourceAddress", "type": "string", "default": "", "doc": "Address to the kafka broker which holds the source of truth topic for this store version."},
                    {"name": "bufferReplayEnabledForHybrid", "type": "boolean", "default": true, "doc": "Whether or not to enable buffer replay for hybrid."},
                    {"name": "chunkingEnabled", "type": "boolean", "default": false, "doc": "Whether or not large values are supported (via chunking)."},
                    {"name": "pushType", "type": "int", "default": 0, "doc": "Producer type for this version, and default is 'BATCH'"},
                    {"name": "partitionCount", "type": "int", "default": 0, "doc": "Partition count of this version."},
                    {
                      "name": "partitionerConfig",
                      "type": [
                        "null",
                        "com.linkedin.venice.systemstore.schemas.StorePartitionerConfig"
                      ],
                      "default": null,
                      "doc": "Config for custom partitioning."
                    },
                    {"name": "incrementalPushPolicy", "type": "int", "default": 0, "doc": "Incremental Push Policy to reconcile with real time pushes., and default is 'PUSH_TO_VERSION_TOPIC'"},
                    {"name": "replicationFactor", "type": "int", "default": 3, "doc": "The number of replica this store version is keeping."},
                    {"name": "nativeReplicationSourceFabric", "type": "string", "default": "", "doc": "The source fabric name to be uses in native replication. Remote consumption will happen from kafka in this fabric."},
                    {"name": "incrementalPushEnabled", "type": "boolean", "default": false, "doc": "Flag to see if the store supports incremental push or not"},
                    {"name": "useVersionLevelIncrementalPushEnabled", "type": "boolean", "default": false, "doc": "Flag to see if incrementalPushEnabled config at StoreVersion should be used. This is needed during migration of this config from Store level to Version level. We can deprecate this field later."},
                    {
                      "name": "hybridConfig",
                      "type": [
                        "null",
                        "com.linkedin.venice.systemstore.schemas.StoreHybridConfig"
                      ],
                      "default": null,
                      "doc": "Properties related to Hybrid Store behavior. If absent (null), then the store is not hybrid."
                    },
                    {"name": "useVersionLevelHybridConfig", "type": "boolean", "default": false, "doc": "Flag to see if hybridConfig at StoreVersion should be used. This is needed during migration of this config from Store level to Version level. We can deprecate this field later."},
                    {"name": "activeActiveReplicationEnabled", "type": "boolean", "default": false, "doc": "Whether or not active/active replication is enabled for hybrid stores; eventually this config will replace native replication flag, when all stores are on A/A"},
                    {"name": "timestampMetadataVersionId", "type": "int", "default": -1, "doc": "The A/A timestamp metadata schema version ID that will be used to deserialize metadataPayload."},
                    {
                      "name": "dataRecoveryConfig",
                      "type": [
                        "null",
                        {
                          "name": "DataRecoveryConfig",
                          "type": "record",
                          "fields": [
                            {"name": "dataRecoverySourceFabric", "type": "string", "doc": "The fabric name to be used as the source for data recovery."},
                            {"name": "isDataRecoveryComplete", "type": "boolean", "doc": "Whether or not data recovery is complete."}
                          ]
                        }
                      ],
                      "default": null,
                      "doc": "Properties related to data recovery mode behavior for this version. If absent (null), then the version never went go through data recovery."
                    }
                  ]
                }
              },
              "default": []
            },
            {
              "name": "systemStores",
              "doc": "This field is used to maintain a mapping between each type of system store and the corresponding distinct properties",
              "type": {
                "type": "map",
                "values": {
                  "name": "SystemStoreProperties",
                  "type": "record",
                  "doc": "This type describes all the distinct properties",
                  "fields": [
                    {"name": "largestUsedVersionNumber", "type": "int", "default": 0},
                    {"name": "currentVersion", "type": "int", "default": 0},
                    {"name": "latestVersionPromoteToCurrentTimestamp", "type": "long", "default": -1},
                    {"name": "versions", "type": {"type": "array", "items": "com.linkedin.venice.systemstore.schemas.StoreVersion"}, "default": []}
                  ]
                }
              },
              "default": {}
            }
          ]
        }
      ],
      "default": null
    },
    {
      "name": "storeKeySchemas",
      "doc": "",
      "type": [
        "null",
        {
          "name": "StoreKeySchemas",
          "doc": "This type describes the key schemas of the store",
          "type": "record",
          "fields": [
            {
              "name": "keySchemaMap",
              "doc": "A string to string map representing the mapping from id to key schema.",
              "type": {
                "type": "map",
                "values": "string"
              }
            }
          ]
        }
      ],
      "default": null
    },
    {
      "name": "storeValueSchemas",
      "doc": "",
      "type": [
        "null",
        {
          "name": "StoreValueSchemas",
          "doc": "This type describes the value schemas of the store.",
          "type": "record",
          "fields": [
            {
              "name": "valueSchemaMap",
              "doc": "A string to string map representing the mapping from schema id to value schema string. The value could be an empty string indicating the value schema is stored in another field.",
              "type": {
                "type": "map",
                "values": "string"
              }
            }
          ]
        }
      ],
      "default": null
    },
    {
      "name": "storeValueSchema",
      "doc": "",
      "type": [
        "null",
        {
          "name": "StoreValueSchema",
          "doc": "This type describes a single version of the value schema of the store.",
          "type": "record",
          "fields": [
            {
              "name": "valueSchema",
              "doc": "Store value schema string.",
              "type": "string",
              "default": ""
            }
          ]
        }
      ],
      "default": null
    },
    {
      "name": "storeReplicaStatuses",
      "doc": "This field describes the replica statuses per version per partition, and the mapping is 'host_port' -> 'replica status'",
      "type": [
        "null",
        {
          "type": "map",
          "values": {
            "name": "StoreReplicaStatus",
            "type": "record",
            "doc": "This structure will contain all kinds of info related to one replica",
            "fields": [
              {"name": "status", "type": "int", "doc": "replica status"}
            ]
          }
        }
      ],
      "default": null
    },
    {
      "name": "storeValueSchemaIdsWrittenPerStoreVersion",
      "doc": "This field described the set of value schemas id written by a store version.",
      "type": [
        "null",
        {
          "name": "StoreValueSchemaIdsWrittenPerStoreVersion",
          "doc": "This type describes value schema IDs written by the store version.",
          "type": "array",
          "items": "int"
        }
      ],
      "default": null
    },
    {
      "name": "storeClusterConfig",
      "doc": "This is the Zk's StoreConfig equivalent which contains various Venice cluster information",
      "type": [
        "null",
        {
          "name": "StoreClusterConfig",
          "doc": "This type describes the various Venice cluster information for a store",
          "type": "record",
          "fields": [
            {"name":  "cluster", "type": "string", "default": "", "doc": "The Venice cluster of the store."},
            {"name":  "deleting", "type": "boolean", "default": false, "doc": "Is the store undergoing deletion."},
            {"name":  "migrationDestCluster", "type": ["null", "string"], "default": null, "doc": "The destination cluster for store migration"},
            {"name":  "migrationSrcCluster", "type": ["null", "string"], "default": null, "doc": "The source cluster for store migration"},
            {"name":  "storeName", "type": "string", "default": "", "doc": "The name of the store"}
          ]
        }
      ],
      "default": null
    }
  ]
}
