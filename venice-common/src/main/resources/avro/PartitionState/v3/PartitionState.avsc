{
  "name": "PartitionState",
  "namespace": "com.linkedin.venice.kafka.protocol.state",
  "doc": "This record holds the state necessary for a consumer to checkpoint its progress when consuming a Venice partition. When provided the state in this record, a consumer should thus be able to resume consuming midway through a stream.",
  "type": "record",
  "fields": [
    {
      "name": "offset",
      "doc": "The last Kafka offset consumed successfully in this partition.",
      "type": "long"
    }, {
      "name": "endOfPush",
      "doc": "Whether the EndOfPush control message was consumed in this partition.",
      "type": "boolean"
    }, {
      "name": "sorted",
      "doc": "Whether the messages inside current topic partition between 'StartOfPush' control message and 'EndOfPush' control message is lexicographically sorted by key bytes",
      "type": "boolean",
      "default": false
    }, {
      "name": "lastUpdate",
      "doc": "The last time this PartitionState was updated. Can be compared against the various messageTimestamp in ProducerPartitionState in order to infer lag time between producers and the consumer maintaining this PartitionState.",
      "type": "long"
    }, {
      "name": "startOfBufferReplayOffsets",
      "doc": "This information comes from a ControlMessage sent by the Controller, once per partition, after the EndOfPush ControlMessage, in Hybrid Stores that ingest from both offline and nearline sources. It represents the offsets from the real-time buffer topic at which the Buffer Replay Service started replaying data from the real-time buffer topic onto the store-version topic. The index position of the array corresponds to the partition number in the real-time buffer. This can be used as a synchronization marker between the real-time buffer topic and the store-version topic, akin to how a clapperboard is used to synchronize sound and image in filmmaking. This synchronization marker can in turn be used by the consumer to compute an offset lag. This is an optional field. It will remain null for any non-Hybrid Stores, as well as for any Hybrid Store which has not yet ingested an EndOfPush ControlMessage in all of its partitions.",
      "type": [
        "null",
        {
          "type": "array",
          "items": "long"
        }
      ],
      "default": "null"
    }, {
      "name": "producerStates",
      "doc": "A map of producer GUID -> producer state.",
      "type": {
        "type": "map",
        "values": {
          "name": "ProducerPartitionState",
          "doc": "A record containing the state pertaining to the data sent by one upstream producer into one partition.",
          "type": "record",
          "fields": [
            {
              "name": "segmentNumber",
              "doc": "The current segment number corresponds to the last (highest) segment number for which we have seen a StartOfSegment control message.",
              "type": "int"
            }, {
              "name": "segmentStatus",
              "doc": "The status of the current segment: 0 => NOT_STARTED, 1 => IN_PROGRESS, 2 => END_OF_INTERMEDIATE_SEGMENT, 3 => END_OF_FINAL_SEGMENT.",
              "type": "int"
            }, {
              "name": "messageSequenceNumber",
              "doc": "The current message sequence number, within the current segment, which we have seen for this partition/producer pair.",
              "type": "int"
            }, {
              "name": "messageTimestamp",
              "doc": "The timestamp included in the last message we have seen for this partition/producer pair.",
              "type": "long"
            }, {
              "name": "checksumType",
              "doc": "The current mapping is the following: 0 => None, 1 => MD5, 2 => Adler32, 3 => CRC32.",
              "type": "int"
            }, {
              "name": "checksumState",
              "doc": "The value of the checksum computed since the last StartOfSegment ControlMessage.",
              "type": "bytes"
            }, {
              "name": "aggregates",
              "doc": "The aggregates that have been computed so far since the last StartOfSegment ControlMessage.",
              "type": {
                "type": "map",
                "values": "long"
              }
            }, {
              "name": "debugInfo",
              "doc": "The debug info received as part of the last StartOfSegment ControlMessage.",
              "type": {
                "type": "map",
                "values": "string"
              }
            }
          ]
        }
      }
    }
  ]
}
