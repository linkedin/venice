/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package com.linkedin.venice.admin.protocol.response;

@SuppressWarnings("all")
/** Type describes all the version attributes */
public class ConsumptionStateSnapshot extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = org.apache.avro.Schema.parse("{\"type\":\"record\",\"name\":\"ConsumptionStateSnapshot\",\"namespace\":\"com.linkedin.venice.admin.protocol.response\",\"fields\":[{\"name\":\"partitionId\",\"type\":\"int\",\"doc\":\"The partition which this state snapshot belongs to.\",\"default\":-1},{\"name\":\"hybrid\",\"type\":\"boolean\",\"doc\":\"Whether the store is hybrid.\"},{\"name\":\"isIncrementalPushEnabled\",\"type\":\"boolean\",\"doc\":\"Whether the store is incremental push enabled.\",\"default\":false},{\"name\":\"offsetRecord\",\"type\":[\"null\",\"bytes\",\"string\"],\"doc\":\"Offset checkpoint info and DIV info\",\"default\":null},{\"name\":\"deferredWrite\",\"type\":\"boolean\",\"doc\":\"Whether deferred write mode is enabled currently\",\"default\":false},{\"name\":\"errorReported\",\"type\":\"boolean\",\"doc\":\"Whether error has already been reported\",\"default\":false},{\"name\":\"lagCaughtUp\",\"type\":\"boolean\",\"doc\":\"Whether lag has ever caught up; it doesn't always indicate the current lag status\",\"default\":false},{\"name\":\"completionReported\",\"type\":\"boolean\",\"doc\":\"Whether completion has been reported before\",\"default\":false},{\"name\":\"leaderState\",\"type\":\"string\",\"doc\":\"STANDBY; LEADER; IN_TRANSITION_FROM_STANDBY_TO_LEADER; PAUSE_TRANSITION_FROM_STANDBY_TO_LEADER\",\"default\":\"\"},{\"name\":\"isLatchReleased\",\"type\":\"boolean\",\"doc\":\"Whether transition latch is released\",\"default\":false},{\"name\":\"processedRecordNum\",\"type\":\"int\",\"doc\":\"How many records have been processed since last metric reports\",\"default\":0},{\"name\":\"processedRecordSize\",\"type\":\"int\",\"doc\":\"How much bytes have been processed since last metric reports\",\"default\":0},{\"name\":\"processedRecordSizeSinceLastSync\",\"type\":\"long\",\"doc\":\"How much bytes have been processed since last sync\",\"default\":0},{\"name\":\"consumeRemotely\",\"type\":\"boolean\",\"doc\":\"Whether the node is consuming remotely for this partition\",\"default\":false},{\"name\":\"latestMessageConsumptionTimestampInMs\",\"type\":\"long\",\"doc\":\"the last time when the node consumes any message for this partition\",\"default\":0}]}");
  /** The partition which this state snapshot belongs to. */
  public int partitionId;
  /** Whether the store is hybrid. */
  public boolean hybrid;
  /** Whether the store is incremental push enabled. */
  public boolean isIncrementalPushEnabled;
  /** Offset checkpoint info and DIV info */
  public java.lang.Object offsetRecord;
  /** Whether deferred write mode is enabled currently */
  public boolean deferredWrite;
  /** Whether error has already been reported */
  public boolean errorReported;
  /** Whether lag has ever caught up; it doesn't always indicate the current lag status */
  public boolean lagCaughtUp;
  /** Whether completion has been reported before */
  public boolean completionReported;
  /** STANDBY; LEADER; IN_TRANSITION_FROM_STANDBY_TO_LEADER; PAUSE_TRANSITION_FROM_STANDBY_TO_LEADER */
  public java.lang.CharSequence leaderState;
  /** Whether transition latch is released */
  public boolean isLatchReleased;
  /** How many records have been processed since last metric reports */
  public int processedRecordNum;
  /** How much bytes have been processed since last metric reports */
  public int processedRecordSize;
  /** How much bytes have been processed since last sync */
  public long processedRecordSizeSinceLastSync;
  /** Whether the node is consuming remotely for this partition */
  public boolean consumeRemotely;
  /** the last time when the node consumes any message for this partition */
  public long latestMessageConsumptionTimestampInMs;
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return partitionId;
    case 1: return hybrid;
    case 2: return isIncrementalPushEnabled;
    case 3: return offsetRecord;
    case 4: return deferredWrite;
    case 5: return errorReported;
    case 6: return lagCaughtUp;
    case 7: return completionReported;
    case 8: return leaderState;
    case 9: return isLatchReleased;
    case 10: return processedRecordNum;
    case 11: return processedRecordSize;
    case 12: return processedRecordSizeSinceLastSync;
    case 13: return consumeRemotely;
    case 14: return latestMessageConsumptionTimestampInMs;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: partitionId = (java.lang.Integer)value$; break;
    case 1: hybrid = (java.lang.Boolean)value$; break;
    case 2: isIncrementalPushEnabled = (java.lang.Boolean)value$; break;
    case 3: offsetRecord = (java.lang.Object)value$; break;
    case 4: deferredWrite = (java.lang.Boolean)value$; break;
    case 5: errorReported = (java.lang.Boolean)value$; break;
    case 6: lagCaughtUp = (java.lang.Boolean)value$; break;
    case 7: completionReported = (java.lang.Boolean)value$; break;
    case 8: leaderState = (java.lang.CharSequence)value$; break;
    case 9: isLatchReleased = (java.lang.Boolean)value$; break;
    case 10: processedRecordNum = (java.lang.Integer)value$; break;
    case 11: processedRecordSize = (java.lang.Integer)value$; break;
    case 12: processedRecordSizeSinceLastSync = (java.lang.Long)value$; break;
    case 13: consumeRemotely = (java.lang.Boolean)value$; break;
    case 14: latestMessageConsumptionTimestampInMs = (java.lang.Long)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
}
