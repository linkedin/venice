/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package com.linkedin.venice.controller.kafka.protocol.admin;  
@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class UpdateStore extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"UpdateStore\",\"namespace\":\"com.linkedin.venice.controller.kafka.protocol.admin\",\"fields\":[{\"name\":\"clusterName\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"storeName\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"owner\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"partitionNum\",\"type\":\"int\"},{\"name\":\"currentVersion\",\"type\":\"int\"},{\"name\":\"enableReads\",\"type\":\"boolean\"},{\"name\":\"enableWrites\",\"type\":\"boolean\"},{\"name\":\"storageQuotaInByte\",\"type\":\"long\",\"default\":21474836480},{\"name\":\"readQuotaInCU\",\"type\":\"long\",\"default\":1800},{\"name\":\"hybridStoreConfig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"HybridStoreConfigRecord\",\"fields\":[{\"name\":\"rewindTimeInSeconds\",\"type\":\"long\"},{\"name\":\"offsetLagThresholdToGoOnline\",\"type\":\"long\"}]}],\"default\":null},{\"name\":\"accessControlled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"compressionStrategy\",\"type\":\"int\",\"doc\":\"Using int because Avro Enums are not evolvable\",\"default\":0},{\"name\":\"chunkingEnabled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"singleGetRouterCacheEnabled\",\"type\":\"boolean\",\"default\":false,\"aliases\":[\"routerCacheEnabled\"]},{\"name\":\"batchGetRouterCacheEnabled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"batchGetLimit\",\"type\":\"int\",\"doc\":\"The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid\",\"default\":-1},{\"name\":\"numVersionsToPreserve\",\"type\":\"int\",\"doc\":\"The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here.\",\"default\":0},{\"name\":\"incrementalPushEnabled\",\"type\":\"boolean\",\"doc\":\"a flag to see if the store supports incremental push or not\",\"default\":false},{\"name\":\"isMigrating\",\"type\":\"boolean\",\"doc\":\"Whether or not the store is in the process of migration\",\"default\":false},{\"name\":\"writeComputationEnabled\",\"type\":\"boolean\",\"doc\":\"Whether write-path computation feature is enabled for this store\",\"default\":false},{\"name\":\"readComputationEnabled\",\"type\":\"boolean\",\"doc\":\"Whether read-path computation feature is enabled for this store\",\"default\":false},{\"name\":\"bootstrapToOnlineTimeoutInHours\",\"type\":\"int\",\"doc\":\"Maximum number of hours allowed for the store to transition from bootstrap to online state\",\"default\":24},{\"name\":\"leaderFollowerModelEnabled\",\"type\":\"boolean\",\"doc\":\"Whether or not to use leader follower state transition model for upcoming version\",\"default\":false},{\"name\":\"backupStrategy\",\"type\":\"int\",\"doc\":\"Strategies to store backup versions.\",\"default\":0},{\"name\":\"clientDecompressionEnabled\",\"type\":\"boolean\",\"default\":true},{\"name\":\"schemaAutoRegisterFromPushJobEnabled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"superSetSchemaAutoGenerationForReadComputeEnabled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"hybridStoreOverheadBypass\",\"type\":\"boolean\",\"default\":false},{\"name\":\"hybridStoreDiskQuotaEnabled\",\"type\":\"boolean\",\"doc\":\"Whether or not to enable disk storage quota for a hybrid store\",\"default\":false},{\"name\":\"ETLStoreConfig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"ETLStoreConfigRecord\",\"fields\":[{\"name\":\"etledUserProxyAccount\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}]},{\"name\":\"regularVersionETLEnabled\",\"type\":\"boolean\"},{\"name\":\"futureVersionETLEnabled\",\"type\":\"boolean\"}]}],\"default\":null},{\"name\":\"partitionerConfig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"PartitionerConfigRecord\",\"fields\":[{\"name\":\"partitionerClass\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"partitionerParams\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"string\",\"avro.java.string\":\"String\"},\"avro.java.string\":\"String\"}},{\"name\":\"amplificationFactor\",\"type\":\"int\"}]}],\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  @Deprecated public java.lang.String clusterName;
  @Deprecated public java.lang.String storeName;
  @Deprecated public java.lang.String owner;
  @Deprecated public int partitionNum;
  @Deprecated public int currentVersion;
  @Deprecated public boolean enableReads;
  @Deprecated public boolean enableWrites;
  @Deprecated public long storageQuotaInByte;
  @Deprecated public long readQuotaInCU;
  @Deprecated public com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord hybridStoreConfig;
  @Deprecated public boolean accessControlled;
  /** Using int because Avro Enums are not evolvable */
  @Deprecated public int compressionStrategy;
  @Deprecated public boolean chunkingEnabled;
  @Deprecated public boolean singleGetRouterCacheEnabled;
  @Deprecated public boolean batchGetRouterCacheEnabled;
  /** The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid */
  @Deprecated public int batchGetLimit;
  /** The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here. */
  @Deprecated public int numVersionsToPreserve;
  /** a flag to see if the store supports incremental push or not */
  @Deprecated public boolean incrementalPushEnabled;
  /** Whether or not the store is in the process of migration */
  @Deprecated public boolean isMigrating;
  /** Whether write-path computation feature is enabled for this store */
  @Deprecated public boolean writeComputationEnabled;
  /** Whether read-path computation feature is enabled for this store */
  @Deprecated public boolean readComputationEnabled;
  /** Maximum number of hours allowed for the store to transition from bootstrap to online state */
  @Deprecated public int bootstrapToOnlineTimeoutInHours;
  /** Whether or not to use leader follower state transition model for upcoming version */
  @Deprecated public boolean leaderFollowerModelEnabled;
  /** Strategies to store backup versions. */
  @Deprecated public int backupStrategy;
  @Deprecated public boolean clientDecompressionEnabled;
  @Deprecated public boolean schemaAutoRegisterFromPushJobEnabled;
  @Deprecated public boolean superSetSchemaAutoGenerationForReadComputeEnabled;
  @Deprecated public boolean hybridStoreOverheadBypass;
  /** Whether or not to enable disk storage quota for a hybrid store */
  @Deprecated public boolean hybridStoreDiskQuotaEnabled;
  @Deprecated public com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord ETLStoreConfig;
  @Deprecated public com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord partitionerConfig;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public UpdateStore() {}

  /**
   * All-args constructor.
   */
  public UpdateStore(java.lang.String clusterName, java.lang.String storeName, java.lang.String owner, java.lang.Integer partitionNum, java.lang.Integer currentVersion, java.lang.Boolean enableReads, java.lang.Boolean enableWrites, java.lang.Long storageQuotaInByte, java.lang.Long readQuotaInCU, com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord hybridStoreConfig, java.lang.Boolean accessControlled, java.lang.Integer compressionStrategy, java.lang.Boolean chunkingEnabled, java.lang.Boolean singleGetRouterCacheEnabled, java.lang.Boolean batchGetRouterCacheEnabled, java.lang.Integer batchGetLimit, java.lang.Integer numVersionsToPreserve, java.lang.Boolean incrementalPushEnabled, java.lang.Boolean isMigrating, java.lang.Boolean writeComputationEnabled, java.lang.Boolean readComputationEnabled, java.lang.Integer bootstrapToOnlineTimeoutInHours, java.lang.Boolean leaderFollowerModelEnabled, java.lang.Integer backupStrategy, java.lang.Boolean clientDecompressionEnabled, java.lang.Boolean schemaAutoRegisterFromPushJobEnabled, java.lang.Boolean superSetSchemaAutoGenerationForReadComputeEnabled, java.lang.Boolean hybridStoreOverheadBypass, java.lang.Boolean hybridStoreDiskQuotaEnabled, com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord ETLStoreConfig, com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord partitionerConfig) {
    this.clusterName = clusterName;
    this.storeName = storeName;
    this.owner = owner;
    this.partitionNum = partitionNum;
    this.currentVersion = currentVersion;
    this.enableReads = enableReads;
    this.enableWrites = enableWrites;
    this.storageQuotaInByte = storageQuotaInByte;
    this.readQuotaInCU = readQuotaInCU;
    this.hybridStoreConfig = hybridStoreConfig;
    this.accessControlled = accessControlled;
    this.compressionStrategy = compressionStrategy;
    this.chunkingEnabled = chunkingEnabled;
    this.singleGetRouterCacheEnabled = singleGetRouterCacheEnabled;
    this.batchGetRouterCacheEnabled = batchGetRouterCacheEnabled;
    this.batchGetLimit = batchGetLimit;
    this.numVersionsToPreserve = numVersionsToPreserve;
    this.incrementalPushEnabled = incrementalPushEnabled;
    this.isMigrating = isMigrating;
    this.writeComputationEnabled = writeComputationEnabled;
    this.readComputationEnabled = readComputationEnabled;
    this.bootstrapToOnlineTimeoutInHours = bootstrapToOnlineTimeoutInHours;
    this.leaderFollowerModelEnabled = leaderFollowerModelEnabled;
    this.backupStrategy = backupStrategy;
    this.clientDecompressionEnabled = clientDecompressionEnabled;
    this.schemaAutoRegisterFromPushJobEnabled = schemaAutoRegisterFromPushJobEnabled;
    this.superSetSchemaAutoGenerationForReadComputeEnabled = superSetSchemaAutoGenerationForReadComputeEnabled;
    this.hybridStoreOverheadBypass = hybridStoreOverheadBypass;
    this.hybridStoreDiskQuotaEnabled = hybridStoreDiskQuotaEnabled;
    this.ETLStoreConfig = ETLStoreConfig;
    this.partitionerConfig = partitionerConfig;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return clusterName;
    case 1: return storeName;
    case 2: return owner;
    case 3: return partitionNum;
    case 4: return currentVersion;
    case 5: return enableReads;
    case 6: return enableWrites;
    case 7: return storageQuotaInByte;
    case 8: return readQuotaInCU;
    case 9: return hybridStoreConfig;
    case 10: return accessControlled;
    case 11: return compressionStrategy;
    case 12: return chunkingEnabled;
    case 13: return singleGetRouterCacheEnabled;
    case 14: return batchGetRouterCacheEnabled;
    case 15: return batchGetLimit;
    case 16: return numVersionsToPreserve;
    case 17: return incrementalPushEnabled;
    case 18: return isMigrating;
    case 19: return writeComputationEnabled;
    case 20: return readComputationEnabled;
    case 21: return bootstrapToOnlineTimeoutInHours;
    case 22: return leaderFollowerModelEnabled;
    case 23: return backupStrategy;
    case 24: return clientDecompressionEnabled;
    case 25: return schemaAutoRegisterFromPushJobEnabled;
    case 26: return superSetSchemaAutoGenerationForReadComputeEnabled;
    case 27: return hybridStoreOverheadBypass;
    case 28: return hybridStoreDiskQuotaEnabled;
    case 29: return ETLStoreConfig;
    case 30: return partitionerConfig;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: clusterName = (java.lang.String)value$; break;
    case 1: storeName = (java.lang.String)value$; break;
    case 2: owner = (java.lang.String)value$; break;
    case 3: partitionNum = (java.lang.Integer)value$; break;
    case 4: currentVersion = (java.lang.Integer)value$; break;
    case 5: enableReads = (java.lang.Boolean)value$; break;
    case 6: enableWrites = (java.lang.Boolean)value$; break;
    case 7: storageQuotaInByte = (java.lang.Long)value$; break;
    case 8: readQuotaInCU = (java.lang.Long)value$; break;
    case 9: hybridStoreConfig = (com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord)value$; break;
    case 10: accessControlled = (java.lang.Boolean)value$; break;
    case 11: compressionStrategy = (java.lang.Integer)value$; break;
    case 12: chunkingEnabled = (java.lang.Boolean)value$; break;
    case 13: singleGetRouterCacheEnabled = (java.lang.Boolean)value$; break;
    case 14: batchGetRouterCacheEnabled = (java.lang.Boolean)value$; break;
    case 15: batchGetLimit = (java.lang.Integer)value$; break;
    case 16: numVersionsToPreserve = (java.lang.Integer)value$; break;
    case 17: incrementalPushEnabled = (java.lang.Boolean)value$; break;
    case 18: isMigrating = (java.lang.Boolean)value$; break;
    case 19: writeComputationEnabled = (java.lang.Boolean)value$; break;
    case 20: readComputationEnabled = (java.lang.Boolean)value$; break;
    case 21: bootstrapToOnlineTimeoutInHours = (java.lang.Integer)value$; break;
    case 22: leaderFollowerModelEnabled = (java.lang.Boolean)value$; break;
    case 23: backupStrategy = (java.lang.Integer)value$; break;
    case 24: clientDecompressionEnabled = (java.lang.Boolean)value$; break;
    case 25: schemaAutoRegisterFromPushJobEnabled = (java.lang.Boolean)value$; break;
    case 26: superSetSchemaAutoGenerationForReadComputeEnabled = (java.lang.Boolean)value$; break;
    case 27: hybridStoreOverheadBypass = (java.lang.Boolean)value$; break;
    case 28: hybridStoreDiskQuotaEnabled = (java.lang.Boolean)value$; break;
    case 29: ETLStoreConfig = (com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord)value$; break;
    case 30: partitionerConfig = (com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'clusterName' field.
   */
  public java.lang.String getClusterName() {
    return clusterName;
  }

  /**
   * Sets the value of the 'clusterName' field.
   * @param value the value to set.
   */
  public void setClusterName(java.lang.String value) {
    this.clusterName = value;
  }

  /**
   * Gets the value of the 'storeName' field.
   */
  public java.lang.String getStoreName() {
    return storeName;
  }

  /**
   * Sets the value of the 'storeName' field.
   * @param value the value to set.
   */
  public void setStoreName(java.lang.String value) {
    this.storeName = value;
  }

  /**
   * Gets the value of the 'owner' field.
   */
  public java.lang.String getOwner() {
    return owner;
  }

  /**
   * Sets the value of the 'owner' field.
   * @param value the value to set.
   */
  public void setOwner(java.lang.String value) {
    this.owner = value;
  }

  /**
   * Gets the value of the 'partitionNum' field.
   */
  public java.lang.Integer getPartitionNum() {
    return partitionNum;
  }

  /**
   * Sets the value of the 'partitionNum' field.
   * @param value the value to set.
   */
  public void setPartitionNum(java.lang.Integer value) {
    this.partitionNum = value;
  }

  /**
   * Gets the value of the 'currentVersion' field.
   */
  public java.lang.Integer getCurrentVersion() {
    return currentVersion;
  }

  /**
   * Sets the value of the 'currentVersion' field.
   * @param value the value to set.
   */
  public void setCurrentVersion(java.lang.Integer value) {
    this.currentVersion = value;
  }

  /**
   * Gets the value of the 'enableReads' field.
   */
  public java.lang.Boolean getEnableReads() {
    return enableReads;
  }

  /**
   * Sets the value of the 'enableReads' field.
   * @param value the value to set.
   */
  public void setEnableReads(java.lang.Boolean value) {
    this.enableReads = value;
  }

  /**
   * Gets the value of the 'enableWrites' field.
   */
  public java.lang.Boolean getEnableWrites() {
    return enableWrites;
  }

  /**
   * Sets the value of the 'enableWrites' field.
   * @param value the value to set.
   */
  public void setEnableWrites(java.lang.Boolean value) {
    this.enableWrites = value;
  }

  /**
   * Gets the value of the 'storageQuotaInByte' field.
   */
  public java.lang.Long getStorageQuotaInByte() {
    return storageQuotaInByte;
  }

  /**
   * Sets the value of the 'storageQuotaInByte' field.
   * @param value the value to set.
   */
  public void setStorageQuotaInByte(java.lang.Long value) {
    this.storageQuotaInByte = value;
  }

  /**
   * Gets the value of the 'readQuotaInCU' field.
   */
  public java.lang.Long getReadQuotaInCU() {
    return readQuotaInCU;
  }

  /**
   * Sets the value of the 'readQuotaInCU' field.
   * @param value the value to set.
   */
  public void setReadQuotaInCU(java.lang.Long value) {
    this.readQuotaInCU = value;
  }

  /**
   * Gets the value of the 'hybridStoreConfig' field.
   */
  public com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord getHybridStoreConfig() {
    return hybridStoreConfig;
  }

  /**
   * Sets the value of the 'hybridStoreConfig' field.
   * @param value the value to set.
   */
  public void setHybridStoreConfig(com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord value) {
    this.hybridStoreConfig = value;
  }

  /**
   * Gets the value of the 'accessControlled' field.
   */
  public java.lang.Boolean getAccessControlled() {
    return accessControlled;
  }

  /**
   * Sets the value of the 'accessControlled' field.
   * @param value the value to set.
   */
  public void setAccessControlled(java.lang.Boolean value) {
    this.accessControlled = value;
  }

  /**
   * Gets the value of the 'compressionStrategy' field.
   * Using int because Avro Enums are not evolvable   */
  public java.lang.Integer getCompressionStrategy() {
    return compressionStrategy;
  }

  /**
   * Sets the value of the 'compressionStrategy' field.
   * Using int because Avro Enums are not evolvable   * @param value the value to set.
   */
  public void setCompressionStrategy(java.lang.Integer value) {
    this.compressionStrategy = value;
  }

  /**
   * Gets the value of the 'chunkingEnabled' field.
   */
  public java.lang.Boolean getChunkingEnabled() {
    return chunkingEnabled;
  }

  /**
   * Sets the value of the 'chunkingEnabled' field.
   * @param value the value to set.
   */
  public void setChunkingEnabled(java.lang.Boolean value) {
    this.chunkingEnabled = value;
  }

  /**
   * Gets the value of the 'singleGetRouterCacheEnabled' field.
   */
  public java.lang.Boolean getSingleGetRouterCacheEnabled() {
    return singleGetRouterCacheEnabled;
  }

  /**
   * Sets the value of the 'singleGetRouterCacheEnabled' field.
   * @param value the value to set.
   */
  public void setSingleGetRouterCacheEnabled(java.lang.Boolean value) {
    this.singleGetRouterCacheEnabled = value;
  }

  /**
   * Gets the value of the 'batchGetRouterCacheEnabled' field.
   */
  public java.lang.Boolean getBatchGetRouterCacheEnabled() {
    return batchGetRouterCacheEnabled;
  }

  /**
   * Sets the value of the 'batchGetRouterCacheEnabled' field.
   * @param value the value to set.
   */
  public void setBatchGetRouterCacheEnabled(java.lang.Boolean value) {
    this.batchGetRouterCacheEnabled = value;
  }

  /**
   * Gets the value of the 'batchGetLimit' field.
   * The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid   */
  public java.lang.Integer getBatchGetLimit() {
    return batchGetLimit;
  }

  /**
   * Sets the value of the 'batchGetLimit' field.
   * The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid   * @param value the value to set.
   */
  public void setBatchGetLimit(java.lang.Integer value) {
    this.batchGetLimit = value;
  }

  /**
   * Gets the value of the 'numVersionsToPreserve' field.
   * The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here.   */
  public java.lang.Integer getNumVersionsToPreserve() {
    return numVersionsToPreserve;
  }

  /**
   * Sets the value of the 'numVersionsToPreserve' field.
   * The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here.   * @param value the value to set.
   */
  public void setNumVersionsToPreserve(java.lang.Integer value) {
    this.numVersionsToPreserve = value;
  }

  /**
   * Gets the value of the 'incrementalPushEnabled' field.
   * a flag to see if the store supports incremental push or not   */
  public java.lang.Boolean getIncrementalPushEnabled() {
    return incrementalPushEnabled;
  }

  /**
   * Sets the value of the 'incrementalPushEnabled' field.
   * a flag to see if the store supports incremental push or not   * @param value the value to set.
   */
  public void setIncrementalPushEnabled(java.lang.Boolean value) {
    this.incrementalPushEnabled = value;
  }

  /**
   * Gets the value of the 'isMigrating' field.
   * Whether or not the store is in the process of migration   */
  public java.lang.Boolean getIsMigrating() {
    return isMigrating;
  }

  /**
   * Sets the value of the 'isMigrating' field.
   * Whether or not the store is in the process of migration   * @param value the value to set.
   */
  public void setIsMigrating(java.lang.Boolean value) {
    this.isMigrating = value;
  }

  /**
   * Gets the value of the 'writeComputationEnabled' field.
   * Whether write-path computation feature is enabled for this store   */
  public java.lang.Boolean getWriteComputationEnabled() {
    return writeComputationEnabled;
  }

  /**
   * Sets the value of the 'writeComputationEnabled' field.
   * Whether write-path computation feature is enabled for this store   * @param value the value to set.
   */
  public void setWriteComputationEnabled(java.lang.Boolean value) {
    this.writeComputationEnabled = value;
  }

  /**
   * Gets the value of the 'readComputationEnabled' field.
   * Whether read-path computation feature is enabled for this store   */
  public java.lang.Boolean getReadComputationEnabled() {
    return readComputationEnabled;
  }

  /**
   * Sets the value of the 'readComputationEnabled' field.
   * Whether read-path computation feature is enabled for this store   * @param value the value to set.
   */
  public void setReadComputationEnabled(java.lang.Boolean value) {
    this.readComputationEnabled = value;
  }

  /**
   * Gets the value of the 'bootstrapToOnlineTimeoutInHours' field.
   * Maximum number of hours allowed for the store to transition from bootstrap to online state   */
  public java.lang.Integer getBootstrapToOnlineTimeoutInHours() {
    return bootstrapToOnlineTimeoutInHours;
  }

  /**
   * Sets the value of the 'bootstrapToOnlineTimeoutInHours' field.
   * Maximum number of hours allowed for the store to transition from bootstrap to online state   * @param value the value to set.
   */
  public void setBootstrapToOnlineTimeoutInHours(java.lang.Integer value) {
    this.bootstrapToOnlineTimeoutInHours = value;
  }

  /**
   * Gets the value of the 'leaderFollowerModelEnabled' field.
   * Whether or not to use leader follower state transition model for upcoming version   */
  public java.lang.Boolean getLeaderFollowerModelEnabled() {
    return leaderFollowerModelEnabled;
  }

  /**
   * Sets the value of the 'leaderFollowerModelEnabled' field.
   * Whether or not to use leader follower state transition model for upcoming version   * @param value the value to set.
   */
  public void setLeaderFollowerModelEnabled(java.lang.Boolean value) {
    this.leaderFollowerModelEnabled = value;
  }

  /**
   * Gets the value of the 'backupStrategy' field.
   * Strategies to store backup versions.   */
  public java.lang.Integer getBackupStrategy() {
    return backupStrategy;
  }

  /**
   * Sets the value of the 'backupStrategy' field.
   * Strategies to store backup versions.   * @param value the value to set.
   */
  public void setBackupStrategy(java.lang.Integer value) {
    this.backupStrategy = value;
  }

  /**
   * Gets the value of the 'clientDecompressionEnabled' field.
   */
  public java.lang.Boolean getClientDecompressionEnabled() {
    return clientDecompressionEnabled;
  }

  /**
   * Sets the value of the 'clientDecompressionEnabled' field.
   * @param value the value to set.
   */
  public void setClientDecompressionEnabled(java.lang.Boolean value) {
    this.clientDecompressionEnabled = value;
  }

  /**
   * Gets the value of the 'schemaAutoRegisterFromPushJobEnabled' field.
   */
  public java.lang.Boolean getSchemaAutoRegisterFromPushJobEnabled() {
    return schemaAutoRegisterFromPushJobEnabled;
  }

  /**
   * Sets the value of the 'schemaAutoRegisterFromPushJobEnabled' field.
   * @param value the value to set.
   */
  public void setSchemaAutoRegisterFromPushJobEnabled(java.lang.Boolean value) {
    this.schemaAutoRegisterFromPushJobEnabled = value;
  }

  /**
   * Gets the value of the 'superSetSchemaAutoGenerationForReadComputeEnabled' field.
   */
  public java.lang.Boolean getSuperSetSchemaAutoGenerationForReadComputeEnabled() {
    return superSetSchemaAutoGenerationForReadComputeEnabled;
  }

  /**
   * Sets the value of the 'superSetSchemaAutoGenerationForReadComputeEnabled' field.
   * @param value the value to set.
   */
  public void setSuperSetSchemaAutoGenerationForReadComputeEnabled(java.lang.Boolean value) {
    this.superSetSchemaAutoGenerationForReadComputeEnabled = value;
  }

  /**
   * Gets the value of the 'hybridStoreOverheadBypass' field.
   */
  public java.lang.Boolean getHybridStoreOverheadBypass() {
    return hybridStoreOverheadBypass;
  }

  /**
   * Sets the value of the 'hybridStoreOverheadBypass' field.
   * @param value the value to set.
   */
  public void setHybridStoreOverheadBypass(java.lang.Boolean value) {
    this.hybridStoreOverheadBypass = value;
  }

  /**
   * Gets the value of the 'hybridStoreDiskQuotaEnabled' field.
   * Whether or not to enable disk storage quota for a hybrid store   */
  public java.lang.Boolean getHybridStoreDiskQuotaEnabled() {
    return hybridStoreDiskQuotaEnabled;
  }

  /**
   * Sets the value of the 'hybridStoreDiskQuotaEnabled' field.
   * Whether or not to enable disk storage quota for a hybrid store   * @param value the value to set.
   */
  public void setHybridStoreDiskQuotaEnabled(java.lang.Boolean value) {
    this.hybridStoreDiskQuotaEnabled = value;
  }

  /**
   * Gets the value of the 'ETLStoreConfig' field.
   */
  public com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord getETLStoreConfig() {
    return ETLStoreConfig;
  }

  /**
   * Sets the value of the 'ETLStoreConfig' field.
   * @param value the value to set.
   */
  public void setETLStoreConfig(com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord value) {
    this.ETLStoreConfig = value;
  }

  /**
   * Gets the value of the 'partitionerConfig' field.
   */
  public com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord getPartitionerConfig() {
    return partitionerConfig;
  }

  /**
   * Sets the value of the 'partitionerConfig' field.
   * @param value the value to set.
   */
  public void setPartitionerConfig(com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord value) {
    this.partitionerConfig = value;
  }

  /** Creates a new UpdateStore RecordBuilder */
  public static com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder newBuilder() {
    return new com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder();
  }
  
  /** Creates a new UpdateStore RecordBuilder by copying an existing Builder */
  public static com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder newBuilder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder other) {
    return new com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder(other);
  }
  
  /** Creates a new UpdateStore RecordBuilder by copying an existing UpdateStore instance */
  public static com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder newBuilder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore other) {
    return new com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder(other);
  }
  
  /**
   * RecordBuilder for UpdateStore instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<UpdateStore>
    implements org.apache.avro.data.RecordBuilder<UpdateStore> {

    private java.lang.String clusterName;
    private java.lang.String storeName;
    private java.lang.String owner;
    private int partitionNum;
    private int currentVersion;
    private boolean enableReads;
    private boolean enableWrites;
    private long storageQuotaInByte;
    private long readQuotaInCU;
    private com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord hybridStoreConfig;
    private boolean accessControlled;
    private int compressionStrategy;
    private boolean chunkingEnabled;
    private boolean singleGetRouterCacheEnabled;
    private boolean batchGetRouterCacheEnabled;
    private int batchGetLimit;
    private int numVersionsToPreserve;
    private boolean incrementalPushEnabled;
    private boolean isMigrating;
    private boolean writeComputationEnabled;
    private boolean readComputationEnabled;
    private int bootstrapToOnlineTimeoutInHours;
    private boolean leaderFollowerModelEnabled;
    private int backupStrategy;
    private boolean clientDecompressionEnabled;
    private boolean schemaAutoRegisterFromPushJobEnabled;
    private boolean superSetSchemaAutoGenerationForReadComputeEnabled;
    private boolean hybridStoreOverheadBypass;
    private boolean hybridStoreDiskQuotaEnabled;
    private com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord ETLStoreConfig;
    private com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord partitionerConfig;

    /** Creates a new Builder */
    private Builder() {
      super(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.clusterName)) {
        this.clusterName = data().deepCopy(fields()[0].schema(), other.clusterName);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.storeName)) {
        this.storeName = data().deepCopy(fields()[1].schema(), other.storeName);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.owner)) {
        this.owner = data().deepCopy(fields()[2].schema(), other.owner);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.partitionNum)) {
        this.partitionNum = data().deepCopy(fields()[3].schema(), other.partitionNum);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.currentVersion)) {
        this.currentVersion = data().deepCopy(fields()[4].schema(), other.currentVersion);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.enableReads)) {
        this.enableReads = data().deepCopy(fields()[5].schema(), other.enableReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.enableWrites)) {
        this.enableWrites = data().deepCopy(fields()[6].schema(), other.enableWrites);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.storageQuotaInByte)) {
        this.storageQuotaInByte = data().deepCopy(fields()[7].schema(), other.storageQuotaInByte);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.readQuotaInCU)) {
        this.readQuotaInCU = data().deepCopy(fields()[8].schema(), other.readQuotaInCU);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.hybridStoreConfig)) {
        this.hybridStoreConfig = data().deepCopy(fields()[9].schema(), other.hybridStoreConfig);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.accessControlled)) {
        this.accessControlled = data().deepCopy(fields()[10].schema(), other.accessControlled);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.compressionStrategy)) {
        this.compressionStrategy = data().deepCopy(fields()[11].schema(), other.compressionStrategy);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.chunkingEnabled)) {
        this.chunkingEnabled = data().deepCopy(fields()[12].schema(), other.chunkingEnabled);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.singleGetRouterCacheEnabled)) {
        this.singleGetRouterCacheEnabled = data().deepCopy(fields()[13].schema(), other.singleGetRouterCacheEnabled);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.batchGetRouterCacheEnabled)) {
        this.batchGetRouterCacheEnabled = data().deepCopy(fields()[14].schema(), other.batchGetRouterCacheEnabled);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.batchGetLimit)) {
        this.batchGetLimit = data().deepCopy(fields()[15].schema(), other.batchGetLimit);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.numVersionsToPreserve)) {
        this.numVersionsToPreserve = data().deepCopy(fields()[16].schema(), other.numVersionsToPreserve);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.incrementalPushEnabled)) {
        this.incrementalPushEnabled = data().deepCopy(fields()[17].schema(), other.incrementalPushEnabled);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.isMigrating)) {
        this.isMigrating = data().deepCopy(fields()[18].schema(), other.isMigrating);
        fieldSetFlags()[18] = true;
      }
      if (isValidValue(fields()[19], other.writeComputationEnabled)) {
        this.writeComputationEnabled = data().deepCopy(fields()[19].schema(), other.writeComputationEnabled);
        fieldSetFlags()[19] = true;
      }
      if (isValidValue(fields()[20], other.readComputationEnabled)) {
        this.readComputationEnabled = data().deepCopy(fields()[20].schema(), other.readComputationEnabled);
        fieldSetFlags()[20] = true;
      }
      if (isValidValue(fields()[21], other.bootstrapToOnlineTimeoutInHours)) {
        this.bootstrapToOnlineTimeoutInHours = data().deepCopy(fields()[21].schema(), other.bootstrapToOnlineTimeoutInHours);
        fieldSetFlags()[21] = true;
      }
      if (isValidValue(fields()[22], other.leaderFollowerModelEnabled)) {
        this.leaderFollowerModelEnabled = data().deepCopy(fields()[22].schema(), other.leaderFollowerModelEnabled);
        fieldSetFlags()[22] = true;
      }
      if (isValidValue(fields()[23], other.backupStrategy)) {
        this.backupStrategy = data().deepCopy(fields()[23].schema(), other.backupStrategy);
        fieldSetFlags()[23] = true;
      }
      if (isValidValue(fields()[24], other.clientDecompressionEnabled)) {
        this.clientDecompressionEnabled = data().deepCopy(fields()[24].schema(), other.clientDecompressionEnabled);
        fieldSetFlags()[24] = true;
      }
      if (isValidValue(fields()[25], other.schemaAutoRegisterFromPushJobEnabled)) {
        this.schemaAutoRegisterFromPushJobEnabled = data().deepCopy(fields()[25].schema(), other.schemaAutoRegisterFromPushJobEnabled);
        fieldSetFlags()[25] = true;
      }
      if (isValidValue(fields()[26], other.superSetSchemaAutoGenerationForReadComputeEnabled)) {
        this.superSetSchemaAutoGenerationForReadComputeEnabled = data().deepCopy(fields()[26].schema(), other.superSetSchemaAutoGenerationForReadComputeEnabled);
        fieldSetFlags()[26] = true;
      }
      if (isValidValue(fields()[27], other.hybridStoreOverheadBypass)) {
        this.hybridStoreOverheadBypass = data().deepCopy(fields()[27].schema(), other.hybridStoreOverheadBypass);
        fieldSetFlags()[27] = true;
      }
      if (isValidValue(fields()[28], other.hybridStoreDiskQuotaEnabled)) {
        this.hybridStoreDiskQuotaEnabled = data().deepCopy(fields()[28].schema(), other.hybridStoreDiskQuotaEnabled);
        fieldSetFlags()[28] = true;
      }
      if (isValidValue(fields()[29], other.ETLStoreConfig)) {
        this.ETLStoreConfig = data().deepCopy(fields()[29].schema(), other.ETLStoreConfig);
        fieldSetFlags()[29] = true;
      }
      if (isValidValue(fields()[30], other.partitionerConfig)) {
        this.partitionerConfig = data().deepCopy(fields()[30].schema(), other.partitionerConfig);
        fieldSetFlags()[30] = true;
      }
    }
    
    /** Creates a Builder by copying an existing UpdateStore instance */
    private Builder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore other) {
            super(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.SCHEMA$);
      if (isValidValue(fields()[0], other.clusterName)) {
        this.clusterName = data().deepCopy(fields()[0].schema(), other.clusterName);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.storeName)) {
        this.storeName = data().deepCopy(fields()[1].schema(), other.storeName);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.owner)) {
        this.owner = data().deepCopy(fields()[2].schema(), other.owner);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.partitionNum)) {
        this.partitionNum = data().deepCopy(fields()[3].schema(), other.partitionNum);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.currentVersion)) {
        this.currentVersion = data().deepCopy(fields()[4].schema(), other.currentVersion);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.enableReads)) {
        this.enableReads = data().deepCopy(fields()[5].schema(), other.enableReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.enableWrites)) {
        this.enableWrites = data().deepCopy(fields()[6].schema(), other.enableWrites);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.storageQuotaInByte)) {
        this.storageQuotaInByte = data().deepCopy(fields()[7].schema(), other.storageQuotaInByte);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.readQuotaInCU)) {
        this.readQuotaInCU = data().deepCopy(fields()[8].schema(), other.readQuotaInCU);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.hybridStoreConfig)) {
        this.hybridStoreConfig = data().deepCopy(fields()[9].schema(), other.hybridStoreConfig);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.accessControlled)) {
        this.accessControlled = data().deepCopy(fields()[10].schema(), other.accessControlled);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.compressionStrategy)) {
        this.compressionStrategy = data().deepCopy(fields()[11].schema(), other.compressionStrategy);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.chunkingEnabled)) {
        this.chunkingEnabled = data().deepCopy(fields()[12].schema(), other.chunkingEnabled);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.singleGetRouterCacheEnabled)) {
        this.singleGetRouterCacheEnabled = data().deepCopy(fields()[13].schema(), other.singleGetRouterCacheEnabled);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.batchGetRouterCacheEnabled)) {
        this.batchGetRouterCacheEnabled = data().deepCopy(fields()[14].schema(), other.batchGetRouterCacheEnabled);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.batchGetLimit)) {
        this.batchGetLimit = data().deepCopy(fields()[15].schema(), other.batchGetLimit);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.numVersionsToPreserve)) {
        this.numVersionsToPreserve = data().deepCopy(fields()[16].schema(), other.numVersionsToPreserve);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.incrementalPushEnabled)) {
        this.incrementalPushEnabled = data().deepCopy(fields()[17].schema(), other.incrementalPushEnabled);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.isMigrating)) {
        this.isMigrating = data().deepCopy(fields()[18].schema(), other.isMigrating);
        fieldSetFlags()[18] = true;
      }
      if (isValidValue(fields()[19], other.writeComputationEnabled)) {
        this.writeComputationEnabled = data().deepCopy(fields()[19].schema(), other.writeComputationEnabled);
        fieldSetFlags()[19] = true;
      }
      if (isValidValue(fields()[20], other.readComputationEnabled)) {
        this.readComputationEnabled = data().deepCopy(fields()[20].schema(), other.readComputationEnabled);
        fieldSetFlags()[20] = true;
      }
      if (isValidValue(fields()[21], other.bootstrapToOnlineTimeoutInHours)) {
        this.bootstrapToOnlineTimeoutInHours = data().deepCopy(fields()[21].schema(), other.bootstrapToOnlineTimeoutInHours);
        fieldSetFlags()[21] = true;
      }
      if (isValidValue(fields()[22], other.leaderFollowerModelEnabled)) {
        this.leaderFollowerModelEnabled = data().deepCopy(fields()[22].schema(), other.leaderFollowerModelEnabled);
        fieldSetFlags()[22] = true;
      }
      if (isValidValue(fields()[23], other.backupStrategy)) {
        this.backupStrategy = data().deepCopy(fields()[23].schema(), other.backupStrategy);
        fieldSetFlags()[23] = true;
      }
      if (isValidValue(fields()[24], other.clientDecompressionEnabled)) {
        this.clientDecompressionEnabled = data().deepCopy(fields()[24].schema(), other.clientDecompressionEnabled);
        fieldSetFlags()[24] = true;
      }
      if (isValidValue(fields()[25], other.schemaAutoRegisterFromPushJobEnabled)) {
        this.schemaAutoRegisterFromPushJobEnabled = data().deepCopy(fields()[25].schema(), other.schemaAutoRegisterFromPushJobEnabled);
        fieldSetFlags()[25] = true;
      }
      if (isValidValue(fields()[26], other.superSetSchemaAutoGenerationForReadComputeEnabled)) {
        this.superSetSchemaAutoGenerationForReadComputeEnabled = data().deepCopy(fields()[26].schema(), other.superSetSchemaAutoGenerationForReadComputeEnabled);
        fieldSetFlags()[26] = true;
      }
      if (isValidValue(fields()[27], other.hybridStoreOverheadBypass)) {
        this.hybridStoreOverheadBypass = data().deepCopy(fields()[27].schema(), other.hybridStoreOverheadBypass);
        fieldSetFlags()[27] = true;
      }
      if (isValidValue(fields()[28], other.hybridStoreDiskQuotaEnabled)) {
        this.hybridStoreDiskQuotaEnabled = data().deepCopy(fields()[28].schema(), other.hybridStoreDiskQuotaEnabled);
        fieldSetFlags()[28] = true;
      }
      if (isValidValue(fields()[29], other.ETLStoreConfig)) {
        this.ETLStoreConfig = data().deepCopy(fields()[29].schema(), other.ETLStoreConfig);
        fieldSetFlags()[29] = true;
      }
      if (isValidValue(fields()[30], other.partitionerConfig)) {
        this.partitionerConfig = data().deepCopy(fields()[30].schema(), other.partitionerConfig);
        fieldSetFlags()[30] = true;
      }
    }

    /** Gets the value of the 'clusterName' field */
    public java.lang.String getClusterName() {
      return clusterName;
    }
    
    /** Sets the value of the 'clusterName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setClusterName(java.lang.String value) {
      validate(fields()[0], value);
      this.clusterName = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'clusterName' field has been set */
    public boolean hasClusterName() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'clusterName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearClusterName() {
      clusterName = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'storeName' field */
    public java.lang.String getStoreName() {
      return storeName;
    }
    
    /** Sets the value of the 'storeName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setStoreName(java.lang.String value) {
      validate(fields()[1], value);
      this.storeName = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'storeName' field has been set */
    public boolean hasStoreName() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'storeName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearStoreName() {
      storeName = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'owner' field */
    public java.lang.String getOwner() {
      return owner;
    }
    
    /** Sets the value of the 'owner' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setOwner(java.lang.String value) {
      validate(fields()[2], value);
      this.owner = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'owner' field has been set */
    public boolean hasOwner() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'owner' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearOwner() {
      owner = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'partitionNum' field */
    public java.lang.Integer getPartitionNum() {
      return partitionNum;
    }
    
    /** Sets the value of the 'partitionNum' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setPartitionNum(int value) {
      validate(fields()[3], value);
      this.partitionNum = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'partitionNum' field has been set */
    public boolean hasPartitionNum() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'partitionNum' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearPartitionNum() {
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'currentVersion' field */
    public java.lang.Integer getCurrentVersion() {
      return currentVersion;
    }
    
    /** Sets the value of the 'currentVersion' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setCurrentVersion(int value) {
      validate(fields()[4], value);
      this.currentVersion = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'currentVersion' field has been set */
    public boolean hasCurrentVersion() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'currentVersion' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearCurrentVersion() {
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'enableReads' field */
    public java.lang.Boolean getEnableReads() {
      return enableReads;
    }
    
    /** Sets the value of the 'enableReads' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setEnableReads(boolean value) {
      validate(fields()[5], value);
      this.enableReads = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'enableReads' field has been set */
    public boolean hasEnableReads() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'enableReads' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearEnableReads() {
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'enableWrites' field */
    public java.lang.Boolean getEnableWrites() {
      return enableWrites;
    }
    
    /** Sets the value of the 'enableWrites' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setEnableWrites(boolean value) {
      validate(fields()[6], value);
      this.enableWrites = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'enableWrites' field has been set */
    public boolean hasEnableWrites() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'enableWrites' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearEnableWrites() {
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'storageQuotaInByte' field */
    public java.lang.Long getStorageQuotaInByte() {
      return storageQuotaInByte;
    }
    
    /** Sets the value of the 'storageQuotaInByte' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setStorageQuotaInByte(long value) {
      validate(fields()[7], value);
      this.storageQuotaInByte = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'storageQuotaInByte' field has been set */
    public boolean hasStorageQuotaInByte() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'storageQuotaInByte' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearStorageQuotaInByte() {
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'readQuotaInCU' field */
    public java.lang.Long getReadQuotaInCU() {
      return readQuotaInCU;
    }
    
    /** Sets the value of the 'readQuotaInCU' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setReadQuotaInCU(long value) {
      validate(fields()[8], value);
      this.readQuotaInCU = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'readQuotaInCU' field has been set */
    public boolean hasReadQuotaInCU() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'readQuotaInCU' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearReadQuotaInCU() {
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'hybridStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord getHybridStoreConfig() {
      return hybridStoreConfig;
    }
    
    /** Sets the value of the 'hybridStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setHybridStoreConfig(com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord value) {
      validate(fields()[9], value);
      this.hybridStoreConfig = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'hybridStoreConfig' field has been set */
    public boolean hasHybridStoreConfig() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'hybridStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearHybridStoreConfig() {
      hybridStoreConfig = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'accessControlled' field */
    public java.lang.Boolean getAccessControlled() {
      return accessControlled;
    }
    
    /** Sets the value of the 'accessControlled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setAccessControlled(boolean value) {
      validate(fields()[10], value);
      this.accessControlled = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'accessControlled' field has been set */
    public boolean hasAccessControlled() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'accessControlled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearAccessControlled() {
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'compressionStrategy' field */
    public java.lang.Integer getCompressionStrategy() {
      return compressionStrategy;
    }
    
    /** Sets the value of the 'compressionStrategy' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setCompressionStrategy(int value) {
      validate(fields()[11], value);
      this.compressionStrategy = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'compressionStrategy' field has been set */
    public boolean hasCompressionStrategy() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'compressionStrategy' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearCompressionStrategy() {
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'chunkingEnabled' field */
    public java.lang.Boolean getChunkingEnabled() {
      return chunkingEnabled;
    }
    
    /** Sets the value of the 'chunkingEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setChunkingEnabled(boolean value) {
      validate(fields()[12], value);
      this.chunkingEnabled = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'chunkingEnabled' field has been set */
    public boolean hasChunkingEnabled() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'chunkingEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearChunkingEnabled() {
      fieldSetFlags()[12] = false;
      return this;
    }

    /** Gets the value of the 'singleGetRouterCacheEnabled' field */
    public java.lang.Boolean getSingleGetRouterCacheEnabled() {
      return singleGetRouterCacheEnabled;
    }
    
    /** Sets the value of the 'singleGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setSingleGetRouterCacheEnabled(boolean value) {
      validate(fields()[13], value);
      this.singleGetRouterCacheEnabled = value;
      fieldSetFlags()[13] = true;
      return this; 
    }
    
    /** Checks whether the 'singleGetRouterCacheEnabled' field has been set */
    public boolean hasSingleGetRouterCacheEnabled() {
      return fieldSetFlags()[13];
    }
    
    /** Clears the value of the 'singleGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearSingleGetRouterCacheEnabled() {
      fieldSetFlags()[13] = false;
      return this;
    }

    /** Gets the value of the 'batchGetRouterCacheEnabled' field */
    public java.lang.Boolean getBatchGetRouterCacheEnabled() {
      return batchGetRouterCacheEnabled;
    }
    
    /** Sets the value of the 'batchGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setBatchGetRouterCacheEnabled(boolean value) {
      validate(fields()[14], value);
      this.batchGetRouterCacheEnabled = value;
      fieldSetFlags()[14] = true;
      return this; 
    }
    
    /** Checks whether the 'batchGetRouterCacheEnabled' field has been set */
    public boolean hasBatchGetRouterCacheEnabled() {
      return fieldSetFlags()[14];
    }
    
    /** Clears the value of the 'batchGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearBatchGetRouterCacheEnabled() {
      fieldSetFlags()[14] = false;
      return this;
    }

    /** Gets the value of the 'batchGetLimit' field */
    public java.lang.Integer getBatchGetLimit() {
      return batchGetLimit;
    }
    
    /** Sets the value of the 'batchGetLimit' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setBatchGetLimit(int value) {
      validate(fields()[15], value);
      this.batchGetLimit = value;
      fieldSetFlags()[15] = true;
      return this; 
    }
    
    /** Checks whether the 'batchGetLimit' field has been set */
    public boolean hasBatchGetLimit() {
      return fieldSetFlags()[15];
    }
    
    /** Clears the value of the 'batchGetLimit' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearBatchGetLimit() {
      fieldSetFlags()[15] = false;
      return this;
    }

    /** Gets the value of the 'numVersionsToPreserve' field */
    public java.lang.Integer getNumVersionsToPreserve() {
      return numVersionsToPreserve;
    }
    
    /** Sets the value of the 'numVersionsToPreserve' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setNumVersionsToPreserve(int value) {
      validate(fields()[16], value);
      this.numVersionsToPreserve = value;
      fieldSetFlags()[16] = true;
      return this; 
    }
    
    /** Checks whether the 'numVersionsToPreserve' field has been set */
    public boolean hasNumVersionsToPreserve() {
      return fieldSetFlags()[16];
    }
    
    /** Clears the value of the 'numVersionsToPreserve' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearNumVersionsToPreserve() {
      fieldSetFlags()[16] = false;
      return this;
    }

    /** Gets the value of the 'incrementalPushEnabled' field */
    public java.lang.Boolean getIncrementalPushEnabled() {
      return incrementalPushEnabled;
    }
    
    /** Sets the value of the 'incrementalPushEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setIncrementalPushEnabled(boolean value) {
      validate(fields()[17], value);
      this.incrementalPushEnabled = value;
      fieldSetFlags()[17] = true;
      return this; 
    }
    
    /** Checks whether the 'incrementalPushEnabled' field has been set */
    public boolean hasIncrementalPushEnabled() {
      return fieldSetFlags()[17];
    }
    
    /** Clears the value of the 'incrementalPushEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearIncrementalPushEnabled() {
      fieldSetFlags()[17] = false;
      return this;
    }

    /** Gets the value of the 'isMigrating' field */
    public java.lang.Boolean getIsMigrating() {
      return isMigrating;
    }
    
    /** Sets the value of the 'isMigrating' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setIsMigrating(boolean value) {
      validate(fields()[18], value);
      this.isMigrating = value;
      fieldSetFlags()[18] = true;
      return this; 
    }
    
    /** Checks whether the 'isMigrating' field has been set */
    public boolean hasIsMigrating() {
      return fieldSetFlags()[18];
    }
    
    /** Clears the value of the 'isMigrating' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearIsMigrating() {
      fieldSetFlags()[18] = false;
      return this;
    }

    /** Gets the value of the 'writeComputationEnabled' field */
    public java.lang.Boolean getWriteComputationEnabled() {
      return writeComputationEnabled;
    }
    
    /** Sets the value of the 'writeComputationEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setWriteComputationEnabled(boolean value) {
      validate(fields()[19], value);
      this.writeComputationEnabled = value;
      fieldSetFlags()[19] = true;
      return this; 
    }
    
    /** Checks whether the 'writeComputationEnabled' field has been set */
    public boolean hasWriteComputationEnabled() {
      return fieldSetFlags()[19];
    }
    
    /** Clears the value of the 'writeComputationEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearWriteComputationEnabled() {
      fieldSetFlags()[19] = false;
      return this;
    }

    /** Gets the value of the 'readComputationEnabled' field */
    public java.lang.Boolean getReadComputationEnabled() {
      return readComputationEnabled;
    }
    
    /** Sets the value of the 'readComputationEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setReadComputationEnabled(boolean value) {
      validate(fields()[20], value);
      this.readComputationEnabled = value;
      fieldSetFlags()[20] = true;
      return this; 
    }
    
    /** Checks whether the 'readComputationEnabled' field has been set */
    public boolean hasReadComputationEnabled() {
      return fieldSetFlags()[20];
    }
    
    /** Clears the value of the 'readComputationEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearReadComputationEnabled() {
      fieldSetFlags()[20] = false;
      return this;
    }

    /** Gets the value of the 'bootstrapToOnlineTimeoutInHours' field */
    public java.lang.Integer getBootstrapToOnlineTimeoutInHours() {
      return bootstrapToOnlineTimeoutInHours;
    }
    
    /** Sets the value of the 'bootstrapToOnlineTimeoutInHours' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setBootstrapToOnlineTimeoutInHours(int value) {
      validate(fields()[21], value);
      this.bootstrapToOnlineTimeoutInHours = value;
      fieldSetFlags()[21] = true;
      return this; 
    }
    
    /** Checks whether the 'bootstrapToOnlineTimeoutInHours' field has been set */
    public boolean hasBootstrapToOnlineTimeoutInHours() {
      return fieldSetFlags()[21];
    }
    
    /** Clears the value of the 'bootstrapToOnlineTimeoutInHours' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearBootstrapToOnlineTimeoutInHours() {
      fieldSetFlags()[21] = false;
      return this;
    }

    /** Gets the value of the 'leaderFollowerModelEnabled' field */
    public java.lang.Boolean getLeaderFollowerModelEnabled() {
      return leaderFollowerModelEnabled;
    }
    
    /** Sets the value of the 'leaderFollowerModelEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setLeaderFollowerModelEnabled(boolean value) {
      validate(fields()[22], value);
      this.leaderFollowerModelEnabled = value;
      fieldSetFlags()[22] = true;
      return this; 
    }
    
    /** Checks whether the 'leaderFollowerModelEnabled' field has been set */
    public boolean hasLeaderFollowerModelEnabled() {
      return fieldSetFlags()[22];
    }
    
    /** Clears the value of the 'leaderFollowerModelEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearLeaderFollowerModelEnabled() {
      fieldSetFlags()[22] = false;
      return this;
    }

    /** Gets the value of the 'backupStrategy' field */
    public java.lang.Integer getBackupStrategy() {
      return backupStrategy;
    }
    
    /** Sets the value of the 'backupStrategy' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setBackupStrategy(int value) {
      validate(fields()[23], value);
      this.backupStrategy = value;
      fieldSetFlags()[23] = true;
      return this; 
    }
    
    /** Checks whether the 'backupStrategy' field has been set */
    public boolean hasBackupStrategy() {
      return fieldSetFlags()[23];
    }
    
    /** Clears the value of the 'backupStrategy' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearBackupStrategy() {
      fieldSetFlags()[23] = false;
      return this;
    }

    /** Gets the value of the 'clientDecompressionEnabled' field */
    public java.lang.Boolean getClientDecompressionEnabled() {
      return clientDecompressionEnabled;
    }
    
    /** Sets the value of the 'clientDecompressionEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setClientDecompressionEnabled(boolean value) {
      validate(fields()[24], value);
      this.clientDecompressionEnabled = value;
      fieldSetFlags()[24] = true;
      return this; 
    }
    
    /** Checks whether the 'clientDecompressionEnabled' field has been set */
    public boolean hasClientDecompressionEnabled() {
      return fieldSetFlags()[24];
    }
    
    /** Clears the value of the 'clientDecompressionEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearClientDecompressionEnabled() {
      fieldSetFlags()[24] = false;
      return this;
    }

    /** Gets the value of the 'schemaAutoRegisterFromPushJobEnabled' field */
    public java.lang.Boolean getSchemaAutoRegisterFromPushJobEnabled() {
      return schemaAutoRegisterFromPushJobEnabled;
    }
    
    /** Sets the value of the 'schemaAutoRegisterFromPushJobEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setSchemaAutoRegisterFromPushJobEnabled(boolean value) {
      validate(fields()[25], value);
      this.schemaAutoRegisterFromPushJobEnabled = value;
      fieldSetFlags()[25] = true;
      return this; 
    }
    
    /** Checks whether the 'schemaAutoRegisterFromPushJobEnabled' field has been set */
    public boolean hasSchemaAutoRegisterFromPushJobEnabled() {
      return fieldSetFlags()[25];
    }
    
    /** Clears the value of the 'schemaAutoRegisterFromPushJobEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearSchemaAutoRegisterFromPushJobEnabled() {
      fieldSetFlags()[25] = false;
      return this;
    }

    /** Gets the value of the 'superSetSchemaAutoGenerationForReadComputeEnabled' field */
    public java.lang.Boolean getSuperSetSchemaAutoGenerationForReadComputeEnabled() {
      return superSetSchemaAutoGenerationForReadComputeEnabled;
    }
    
    /** Sets the value of the 'superSetSchemaAutoGenerationForReadComputeEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setSuperSetSchemaAutoGenerationForReadComputeEnabled(boolean value) {
      validate(fields()[26], value);
      this.superSetSchemaAutoGenerationForReadComputeEnabled = value;
      fieldSetFlags()[26] = true;
      return this; 
    }
    
    /** Checks whether the 'superSetSchemaAutoGenerationForReadComputeEnabled' field has been set */
    public boolean hasSuperSetSchemaAutoGenerationForReadComputeEnabled() {
      return fieldSetFlags()[26];
    }
    
    /** Clears the value of the 'superSetSchemaAutoGenerationForReadComputeEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearSuperSetSchemaAutoGenerationForReadComputeEnabled() {
      fieldSetFlags()[26] = false;
      return this;
    }

    /** Gets the value of the 'hybridStoreOverheadBypass' field */
    public java.lang.Boolean getHybridStoreOverheadBypass() {
      return hybridStoreOverheadBypass;
    }
    
    /** Sets the value of the 'hybridStoreOverheadBypass' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setHybridStoreOverheadBypass(boolean value) {
      validate(fields()[27], value);
      this.hybridStoreOverheadBypass = value;
      fieldSetFlags()[27] = true;
      return this; 
    }
    
    /** Checks whether the 'hybridStoreOverheadBypass' field has been set */
    public boolean hasHybridStoreOverheadBypass() {
      return fieldSetFlags()[27];
    }
    
    /** Clears the value of the 'hybridStoreOverheadBypass' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearHybridStoreOverheadBypass() {
      fieldSetFlags()[27] = false;
      return this;
    }

    /** Gets the value of the 'hybridStoreDiskQuotaEnabled' field */
    public java.lang.Boolean getHybridStoreDiskQuotaEnabled() {
      return hybridStoreDiskQuotaEnabled;
    }
    
    /** Sets the value of the 'hybridStoreDiskQuotaEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setHybridStoreDiskQuotaEnabled(boolean value) {
      validate(fields()[28], value);
      this.hybridStoreDiskQuotaEnabled = value;
      fieldSetFlags()[28] = true;
      return this; 
    }
    
    /** Checks whether the 'hybridStoreDiskQuotaEnabled' field has been set */
    public boolean hasHybridStoreDiskQuotaEnabled() {
      return fieldSetFlags()[28];
    }
    
    /** Clears the value of the 'hybridStoreDiskQuotaEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearHybridStoreDiskQuotaEnabled() {
      fieldSetFlags()[28] = false;
      return this;
    }

    /** Gets the value of the 'ETLStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord getETLStoreConfig() {
      return ETLStoreConfig;
    }
    
    /** Sets the value of the 'ETLStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setETLStoreConfig(com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord value) {
      validate(fields()[29], value);
      this.ETLStoreConfig = value;
      fieldSetFlags()[29] = true;
      return this; 
    }
    
    /** Checks whether the 'ETLStoreConfig' field has been set */
    public boolean hasETLStoreConfig() {
      return fieldSetFlags()[29];
    }
    
    /** Clears the value of the 'ETLStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearETLStoreConfig() {
      ETLStoreConfig = null;
      fieldSetFlags()[29] = false;
      return this;
    }

    /** Gets the value of the 'partitionerConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord getPartitionerConfig() {
      return partitionerConfig;
    }
    
    /** Sets the value of the 'partitionerConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setPartitionerConfig(com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord value) {
      validate(fields()[30], value);
      this.partitionerConfig = value;
      fieldSetFlags()[30] = true;
      return this; 
    }
    
    /** Checks whether the 'partitionerConfig' field has been set */
    public boolean hasPartitionerConfig() {
      return fieldSetFlags()[30];
    }
    
    /** Clears the value of the 'partitionerConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearPartitionerConfig() {
      partitionerConfig = null;
      fieldSetFlags()[30] = false;
      return this;
    }

    @Override
    public UpdateStore build() {
      try {
        UpdateStore record = new UpdateStore();
        record.clusterName = fieldSetFlags()[0] ? this.clusterName : (java.lang.String) defaultValue(fields()[0]);
        record.storeName = fieldSetFlags()[1] ? this.storeName : (java.lang.String) defaultValue(fields()[1]);
        record.owner = fieldSetFlags()[2] ? this.owner : (java.lang.String) defaultValue(fields()[2]);
        record.partitionNum = fieldSetFlags()[3] ? this.partitionNum : (java.lang.Integer) defaultValue(fields()[3]);
        record.currentVersion = fieldSetFlags()[4] ? this.currentVersion : (java.lang.Integer) defaultValue(fields()[4]);
        record.enableReads = fieldSetFlags()[5] ? this.enableReads : (java.lang.Boolean) defaultValue(fields()[5]);
        record.enableWrites = fieldSetFlags()[6] ? this.enableWrites : (java.lang.Boolean) defaultValue(fields()[6]);
        record.storageQuotaInByte = fieldSetFlags()[7] ? this.storageQuotaInByte : (java.lang.Long) defaultValue(fields()[7]);
        record.readQuotaInCU = fieldSetFlags()[8] ? this.readQuotaInCU : (java.lang.Long) defaultValue(fields()[8]);
        record.hybridStoreConfig = fieldSetFlags()[9] ? this.hybridStoreConfig : (com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord) defaultValue(fields()[9]);
        record.accessControlled = fieldSetFlags()[10] ? this.accessControlled : (java.lang.Boolean) defaultValue(fields()[10]);
        record.compressionStrategy = fieldSetFlags()[11] ? this.compressionStrategy : (java.lang.Integer) defaultValue(fields()[11]);
        record.chunkingEnabled = fieldSetFlags()[12] ? this.chunkingEnabled : (java.lang.Boolean) defaultValue(fields()[12]);
        record.singleGetRouterCacheEnabled = fieldSetFlags()[13] ? this.singleGetRouterCacheEnabled : (java.lang.Boolean) defaultValue(fields()[13]);
        record.batchGetRouterCacheEnabled = fieldSetFlags()[14] ? this.batchGetRouterCacheEnabled : (java.lang.Boolean) defaultValue(fields()[14]);
        record.batchGetLimit = fieldSetFlags()[15] ? this.batchGetLimit : (java.lang.Integer) defaultValue(fields()[15]);
        record.numVersionsToPreserve = fieldSetFlags()[16] ? this.numVersionsToPreserve : (java.lang.Integer) defaultValue(fields()[16]);
        record.incrementalPushEnabled = fieldSetFlags()[17] ? this.incrementalPushEnabled : (java.lang.Boolean) defaultValue(fields()[17]);
        record.isMigrating = fieldSetFlags()[18] ? this.isMigrating : (java.lang.Boolean) defaultValue(fields()[18]);
        record.writeComputationEnabled = fieldSetFlags()[19] ? this.writeComputationEnabled : (java.lang.Boolean) defaultValue(fields()[19]);
        record.readComputationEnabled = fieldSetFlags()[20] ? this.readComputationEnabled : (java.lang.Boolean) defaultValue(fields()[20]);
        record.bootstrapToOnlineTimeoutInHours = fieldSetFlags()[21] ? this.bootstrapToOnlineTimeoutInHours : (java.lang.Integer) defaultValue(fields()[21]);
        record.leaderFollowerModelEnabled = fieldSetFlags()[22] ? this.leaderFollowerModelEnabled : (java.lang.Boolean) defaultValue(fields()[22]);
        record.backupStrategy = fieldSetFlags()[23] ? this.backupStrategy : (java.lang.Integer) defaultValue(fields()[23]);
        record.clientDecompressionEnabled = fieldSetFlags()[24] ? this.clientDecompressionEnabled : (java.lang.Boolean) defaultValue(fields()[24]);
        record.schemaAutoRegisterFromPushJobEnabled = fieldSetFlags()[25] ? this.schemaAutoRegisterFromPushJobEnabled : (java.lang.Boolean) defaultValue(fields()[25]);
        record.superSetSchemaAutoGenerationForReadComputeEnabled = fieldSetFlags()[26] ? this.superSetSchemaAutoGenerationForReadComputeEnabled : (java.lang.Boolean) defaultValue(fields()[26]);
        record.hybridStoreOverheadBypass = fieldSetFlags()[27] ? this.hybridStoreOverheadBypass : (java.lang.Boolean) defaultValue(fields()[27]);
        record.hybridStoreDiskQuotaEnabled = fieldSetFlags()[28] ? this.hybridStoreDiskQuotaEnabled : (java.lang.Boolean) defaultValue(fields()[28]);
        record.ETLStoreConfig = fieldSetFlags()[29] ? this.ETLStoreConfig : (com.linkedin.venice.controller.kafka.protocol.admin.ETLStoreConfigRecord) defaultValue(fields()[29]);
        record.partitionerConfig = fieldSetFlags()[30] ? this.partitionerConfig : (com.linkedin.venice.controller.kafka.protocol.admin.PartitionerConfigRecord) defaultValue(fields()[30]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
