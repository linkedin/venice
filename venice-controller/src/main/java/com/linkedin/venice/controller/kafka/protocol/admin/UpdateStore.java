/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package com.linkedin.venice.controller.kafka.protocol.admin;  
@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class UpdateStore extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"UpdateStore\",\"namespace\":\"com.linkedin.venice.controller.kafka.protocol.admin\",\"fields\":[{\"name\":\"clusterName\",\"type\":\"string\"},{\"name\":\"storeName\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"string\"},{\"name\":\"partitionNum\",\"type\":\"int\"},{\"name\":\"currentVersion\",\"type\":\"int\"},{\"name\":\"enableReads\",\"type\":\"boolean\"},{\"name\":\"enableWrites\",\"type\":\"boolean\"},{\"name\":\"storageQuotaInByte\",\"type\":\"long\",\"default\":21474836480},{\"name\":\"readQuotaInCU\",\"type\":\"long\",\"default\":1800},{\"name\":\"hybridStoreConfig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"HybridStoreConfigRecord\",\"fields\":[{\"name\":\"rewindTimeInSeconds\",\"type\":\"long\"},{\"name\":\"offsetLagThresholdToGoOnline\",\"type\":\"long\"}]}],\"default\":null},{\"name\":\"accessControlled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"compressionStrategy\",\"type\":\"int\",\"doc\":\"Using int because Avro Enums are not evolvable\",\"default\":0},{\"name\":\"chunkingEnabled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"singleGetRouterCacheEnabled\",\"type\":\"boolean\",\"default\":false,\"aliases\":[\"routerCacheEnabled\"]},{\"name\":\"batchGetRouterCacheEnabled\",\"type\":\"boolean\",\"default\":false},{\"name\":\"batchGetLimit\",\"type\":\"int\",\"doc\":\"The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid\",\"default\":-1},{\"name\":\"numVersionsToPreserve\",\"type\":\"int\",\"doc\":\"The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here.\",\"default\":0}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  @Deprecated public java.lang.CharSequence clusterName;
  @Deprecated public java.lang.CharSequence storeName;
  @Deprecated public java.lang.CharSequence owner;
  @Deprecated public int partitionNum;
  @Deprecated public int currentVersion;
  @Deprecated public boolean enableReads;
  @Deprecated public boolean enableWrites;
  @Deprecated public long storageQuotaInByte;
  @Deprecated public long readQuotaInCU;
  @Deprecated public com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord hybridStoreConfig;
  @Deprecated public boolean accessControlled;
  /** Using int because Avro Enums are not evolvable */
  @Deprecated public int compressionStrategy;
  @Deprecated public boolean chunkingEnabled;
  @Deprecated public boolean singleGetRouterCacheEnabled;
  @Deprecated public boolean batchGetRouterCacheEnabled;
  /** The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid */
  @Deprecated public int batchGetLimit;
  /** The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here. */
  @Deprecated public int numVersionsToPreserve;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public UpdateStore() {}

  /**
   * All-args constructor.
   */
  public UpdateStore(java.lang.CharSequence clusterName, java.lang.CharSequence storeName, java.lang.CharSequence owner, java.lang.Integer partitionNum, java.lang.Integer currentVersion, java.lang.Boolean enableReads, java.lang.Boolean enableWrites, java.lang.Long storageQuotaInByte, java.lang.Long readQuotaInCU, com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord hybridStoreConfig, java.lang.Boolean accessControlled, java.lang.Integer compressionStrategy, java.lang.Boolean chunkingEnabled, java.lang.Boolean singleGetRouterCacheEnabled, java.lang.Boolean batchGetRouterCacheEnabled, java.lang.Integer batchGetLimit, java.lang.Integer numVersionsToPreserve) {
    this.clusterName = clusterName;
    this.storeName = storeName;
    this.owner = owner;
    this.partitionNum = partitionNum;
    this.currentVersion = currentVersion;
    this.enableReads = enableReads;
    this.enableWrites = enableWrites;
    this.storageQuotaInByte = storageQuotaInByte;
    this.readQuotaInCU = readQuotaInCU;
    this.hybridStoreConfig = hybridStoreConfig;
    this.accessControlled = accessControlled;
    this.compressionStrategy = compressionStrategy;
    this.chunkingEnabled = chunkingEnabled;
    this.singleGetRouterCacheEnabled = singleGetRouterCacheEnabled;
    this.batchGetRouterCacheEnabled = batchGetRouterCacheEnabled;
    this.batchGetLimit = batchGetLimit;
    this.numVersionsToPreserve = numVersionsToPreserve;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return clusterName;
    case 1: return storeName;
    case 2: return owner;
    case 3: return partitionNum;
    case 4: return currentVersion;
    case 5: return enableReads;
    case 6: return enableWrites;
    case 7: return storageQuotaInByte;
    case 8: return readQuotaInCU;
    case 9: return hybridStoreConfig;
    case 10: return accessControlled;
    case 11: return compressionStrategy;
    case 12: return chunkingEnabled;
    case 13: return singleGetRouterCacheEnabled;
    case 14: return batchGetRouterCacheEnabled;
    case 15: return batchGetLimit;
    case 16: return numVersionsToPreserve;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: clusterName = (java.lang.CharSequence)value$; break;
    case 1: storeName = (java.lang.CharSequence)value$; break;
    case 2: owner = (java.lang.CharSequence)value$; break;
    case 3: partitionNum = (java.lang.Integer)value$; break;
    case 4: currentVersion = (java.lang.Integer)value$; break;
    case 5: enableReads = (java.lang.Boolean)value$; break;
    case 6: enableWrites = (java.lang.Boolean)value$; break;
    case 7: storageQuotaInByte = (java.lang.Long)value$; break;
    case 8: readQuotaInCU = (java.lang.Long)value$; break;
    case 9: hybridStoreConfig = (com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord)value$; break;
    case 10: accessControlled = (java.lang.Boolean)value$; break;
    case 11: compressionStrategy = (java.lang.Integer)value$; break;
    case 12: chunkingEnabled = (java.lang.Boolean)value$; break;
    case 13: singleGetRouterCacheEnabled = (java.lang.Boolean)value$; break;
    case 14: batchGetRouterCacheEnabled = (java.lang.Boolean)value$; break;
    case 15: batchGetLimit = (java.lang.Integer)value$; break;
    case 16: numVersionsToPreserve = (java.lang.Integer)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'clusterName' field.
   */
  public java.lang.CharSequence getClusterName() {
    return clusterName;
  }

  /**
   * Sets the value of the 'clusterName' field.
   * @param value the value to set.
   */
  public void setClusterName(java.lang.CharSequence value) {
    this.clusterName = value;
  }

  /**
   * Gets the value of the 'storeName' field.
   */
  public java.lang.CharSequence getStoreName() {
    return storeName;
  }

  /**
   * Sets the value of the 'storeName' field.
   * @param value the value to set.
   */
  public void setStoreName(java.lang.CharSequence value) {
    this.storeName = value;
  }

  /**
   * Gets the value of the 'owner' field.
   */
  public java.lang.CharSequence getOwner() {
    return owner;
  }

  /**
   * Sets the value of the 'owner' field.
   * @param value the value to set.
   */
  public void setOwner(java.lang.CharSequence value) {
    this.owner = value;
  }

  /**
   * Gets the value of the 'partitionNum' field.
   */
  public java.lang.Integer getPartitionNum() {
    return partitionNum;
  }

  /**
   * Sets the value of the 'partitionNum' field.
   * @param value the value to set.
   */
  public void setPartitionNum(java.lang.Integer value) {
    this.partitionNum = value;
  }

  /**
   * Gets the value of the 'currentVersion' field.
   */
  public java.lang.Integer getCurrentVersion() {
    return currentVersion;
  }

  /**
   * Sets the value of the 'currentVersion' field.
   * @param value the value to set.
   */
  public void setCurrentVersion(java.lang.Integer value) {
    this.currentVersion = value;
  }

  /**
   * Gets the value of the 'enableReads' field.
   */
  public java.lang.Boolean getEnableReads() {
    return enableReads;
  }

  /**
   * Sets the value of the 'enableReads' field.
   * @param value the value to set.
   */
  public void setEnableReads(java.lang.Boolean value) {
    this.enableReads = value;
  }

  /**
   * Gets the value of the 'enableWrites' field.
   */
  public java.lang.Boolean getEnableWrites() {
    return enableWrites;
  }

  /**
   * Sets the value of the 'enableWrites' field.
   * @param value the value to set.
   */
  public void setEnableWrites(java.lang.Boolean value) {
    this.enableWrites = value;
  }

  /**
   * Gets the value of the 'storageQuotaInByte' field.
   */
  public java.lang.Long getStorageQuotaInByte() {
    return storageQuotaInByte;
  }

  /**
   * Sets the value of the 'storageQuotaInByte' field.
   * @param value the value to set.
   */
  public void setStorageQuotaInByte(java.lang.Long value) {
    this.storageQuotaInByte = value;
  }

  /**
   * Gets the value of the 'readQuotaInCU' field.
   */
  public java.lang.Long getReadQuotaInCU() {
    return readQuotaInCU;
  }

  /**
   * Sets the value of the 'readQuotaInCU' field.
   * @param value the value to set.
   */
  public void setReadQuotaInCU(java.lang.Long value) {
    this.readQuotaInCU = value;
  }

  /**
   * Gets the value of the 'hybridStoreConfig' field.
   */
  public com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord getHybridStoreConfig() {
    return hybridStoreConfig;
  }

  /**
   * Sets the value of the 'hybridStoreConfig' field.
   * @param value the value to set.
   */
  public void setHybridStoreConfig(com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord value) {
    this.hybridStoreConfig = value;
  }

  /**
   * Gets the value of the 'accessControlled' field.
   */
  public java.lang.Boolean getAccessControlled() {
    return accessControlled;
  }

  /**
   * Sets the value of the 'accessControlled' field.
   * @param value the value to set.
   */
  public void setAccessControlled(java.lang.Boolean value) {
    this.accessControlled = value;
  }

  /**
   * Gets the value of the 'compressionStrategy' field.
   * Using int because Avro Enums are not evolvable   */
  public java.lang.Integer getCompressionStrategy() {
    return compressionStrategy;
  }

  /**
   * Sets the value of the 'compressionStrategy' field.
   * Using int because Avro Enums are not evolvable   * @param value the value to set.
   */
  public void setCompressionStrategy(java.lang.Integer value) {
    this.compressionStrategy = value;
  }

  /**
   * Gets the value of the 'chunkingEnabled' field.
   */
  public java.lang.Boolean getChunkingEnabled() {
    return chunkingEnabled;
  }

  /**
   * Sets the value of the 'chunkingEnabled' field.
   * @param value the value to set.
   */
  public void setChunkingEnabled(java.lang.Boolean value) {
    this.chunkingEnabled = value;
  }

  /**
   * Gets the value of the 'singleGetRouterCacheEnabled' field.
   */
  public java.lang.Boolean getSingleGetRouterCacheEnabled() {
    return singleGetRouterCacheEnabled;
  }

  /**
   * Sets the value of the 'singleGetRouterCacheEnabled' field.
   * @param value the value to set.
   */
  public void setSingleGetRouterCacheEnabled(java.lang.Boolean value) {
    this.singleGetRouterCacheEnabled = value;
  }

  /**
   * Gets the value of the 'batchGetRouterCacheEnabled' field.
   */
  public java.lang.Boolean getBatchGetRouterCacheEnabled() {
    return batchGetRouterCacheEnabled;
  }

  /**
   * Sets the value of the 'batchGetRouterCacheEnabled' field.
   * @param value the value to set.
   */
  public void setBatchGetRouterCacheEnabled(java.lang.Boolean value) {
    this.batchGetRouterCacheEnabled = value;
  }

  /**
   * Gets the value of the 'batchGetLimit' field.
   * The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid   */
  public java.lang.Integer getBatchGetLimit() {
    return batchGetLimit;
  }

  /**
   * Sets the value of the 'batchGetLimit' field.
   * The max key number allowed in batch get request, and Venice will use cluster-level config if the limit (not positive) is not valid   * @param value the value to set.
   */
  public void setBatchGetLimit(java.lang.Integer value) {
    this.batchGetLimit = value;
  }

  /**
   * Gets the value of the 'numVersionsToPreserve' field.
   * The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here.   */
  public java.lang.Integer getNumVersionsToPreserve() {
    return numVersionsToPreserve;
  }

  /**
   * Sets the value of the 'numVersionsToPreserve' field.
   * The max number of versions the store should preserve. Venice will use cluster-level config if the number is 0 here.   * @param value the value to set.
   */
  public void setNumVersionsToPreserve(java.lang.Integer value) {
    this.numVersionsToPreserve = value;
  }

  /** Creates a new UpdateStore RecordBuilder */
  public static com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder newBuilder() {
    return new com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder();
  }
  
  /** Creates a new UpdateStore RecordBuilder by copying an existing Builder */
  public static com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder newBuilder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder other) {
    return new com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder(other);
  }
  
  /** Creates a new UpdateStore RecordBuilder by copying an existing UpdateStore instance */
  public static com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder newBuilder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore other) {
    return new com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder(other);
  }
  
  /**
   * RecordBuilder for UpdateStore instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<UpdateStore>
    implements org.apache.avro.data.RecordBuilder<UpdateStore> {

    private java.lang.CharSequence clusterName;
    private java.lang.CharSequence storeName;
    private java.lang.CharSequence owner;
    private int partitionNum;
    private int currentVersion;
    private boolean enableReads;
    private boolean enableWrites;
    private long storageQuotaInByte;
    private long readQuotaInCU;
    private com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord hybridStoreConfig;
    private boolean accessControlled;
    private int compressionStrategy;
    private boolean chunkingEnabled;
    private boolean singleGetRouterCacheEnabled;
    private boolean batchGetRouterCacheEnabled;
    private int batchGetLimit;
    private int numVersionsToPreserve;

    /** Creates a new Builder */
    private Builder() {
      super(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.clusterName)) {
        this.clusterName = data().deepCopy(fields()[0].schema(), other.clusterName);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.storeName)) {
        this.storeName = data().deepCopy(fields()[1].schema(), other.storeName);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.owner)) {
        this.owner = data().deepCopy(fields()[2].schema(), other.owner);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.partitionNum)) {
        this.partitionNum = data().deepCopy(fields()[3].schema(), other.partitionNum);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.currentVersion)) {
        this.currentVersion = data().deepCopy(fields()[4].schema(), other.currentVersion);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.enableReads)) {
        this.enableReads = data().deepCopy(fields()[5].schema(), other.enableReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.enableWrites)) {
        this.enableWrites = data().deepCopy(fields()[6].schema(), other.enableWrites);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.storageQuotaInByte)) {
        this.storageQuotaInByte = data().deepCopy(fields()[7].schema(), other.storageQuotaInByte);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.readQuotaInCU)) {
        this.readQuotaInCU = data().deepCopy(fields()[8].schema(), other.readQuotaInCU);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.hybridStoreConfig)) {
        this.hybridStoreConfig = data().deepCopy(fields()[9].schema(), other.hybridStoreConfig);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.accessControlled)) {
        this.accessControlled = data().deepCopy(fields()[10].schema(), other.accessControlled);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.compressionStrategy)) {
        this.compressionStrategy = data().deepCopy(fields()[11].schema(), other.compressionStrategy);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.chunkingEnabled)) {
        this.chunkingEnabled = data().deepCopy(fields()[12].schema(), other.chunkingEnabled);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.singleGetRouterCacheEnabled)) {
        this.singleGetRouterCacheEnabled = data().deepCopy(fields()[13].schema(), other.singleGetRouterCacheEnabled);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.batchGetRouterCacheEnabled)) {
        this.batchGetRouterCacheEnabled = data().deepCopy(fields()[14].schema(), other.batchGetRouterCacheEnabled);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.batchGetLimit)) {
        this.batchGetLimit = data().deepCopy(fields()[15].schema(), other.batchGetLimit);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.numVersionsToPreserve)) {
        this.numVersionsToPreserve = data().deepCopy(fields()[16].schema(), other.numVersionsToPreserve);
        fieldSetFlags()[16] = true;
      }
    }
    
    /** Creates a Builder by copying an existing UpdateStore instance */
    private Builder(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore other) {
            super(com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.SCHEMA$);
      if (isValidValue(fields()[0], other.clusterName)) {
        this.clusterName = data().deepCopy(fields()[0].schema(), other.clusterName);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.storeName)) {
        this.storeName = data().deepCopy(fields()[1].schema(), other.storeName);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.owner)) {
        this.owner = data().deepCopy(fields()[2].schema(), other.owner);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.partitionNum)) {
        this.partitionNum = data().deepCopy(fields()[3].schema(), other.partitionNum);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.currentVersion)) {
        this.currentVersion = data().deepCopy(fields()[4].schema(), other.currentVersion);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.enableReads)) {
        this.enableReads = data().deepCopy(fields()[5].schema(), other.enableReads);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.enableWrites)) {
        this.enableWrites = data().deepCopy(fields()[6].schema(), other.enableWrites);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.storageQuotaInByte)) {
        this.storageQuotaInByte = data().deepCopy(fields()[7].schema(), other.storageQuotaInByte);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.readQuotaInCU)) {
        this.readQuotaInCU = data().deepCopy(fields()[8].schema(), other.readQuotaInCU);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.hybridStoreConfig)) {
        this.hybridStoreConfig = data().deepCopy(fields()[9].schema(), other.hybridStoreConfig);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.accessControlled)) {
        this.accessControlled = data().deepCopy(fields()[10].schema(), other.accessControlled);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.compressionStrategy)) {
        this.compressionStrategy = data().deepCopy(fields()[11].schema(), other.compressionStrategy);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.chunkingEnabled)) {
        this.chunkingEnabled = data().deepCopy(fields()[12].schema(), other.chunkingEnabled);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.singleGetRouterCacheEnabled)) {
        this.singleGetRouterCacheEnabled = data().deepCopy(fields()[13].schema(), other.singleGetRouterCacheEnabled);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.batchGetRouterCacheEnabled)) {
        this.batchGetRouterCacheEnabled = data().deepCopy(fields()[14].schema(), other.batchGetRouterCacheEnabled);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.batchGetLimit)) {
        this.batchGetLimit = data().deepCopy(fields()[15].schema(), other.batchGetLimit);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.numVersionsToPreserve)) {
        this.numVersionsToPreserve = data().deepCopy(fields()[16].schema(), other.numVersionsToPreserve);
        fieldSetFlags()[16] = true;
      }
    }

    /** Gets the value of the 'clusterName' field */
    public java.lang.CharSequence getClusterName() {
      return clusterName;
    }
    
    /** Sets the value of the 'clusterName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setClusterName(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.clusterName = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'clusterName' field has been set */
    public boolean hasClusterName() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'clusterName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearClusterName() {
      clusterName = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'storeName' field */
    public java.lang.CharSequence getStoreName() {
      return storeName;
    }
    
    /** Sets the value of the 'storeName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setStoreName(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.storeName = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'storeName' field has been set */
    public boolean hasStoreName() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'storeName' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearStoreName() {
      storeName = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'owner' field */
    public java.lang.CharSequence getOwner() {
      return owner;
    }
    
    /** Sets the value of the 'owner' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setOwner(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.owner = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'owner' field has been set */
    public boolean hasOwner() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'owner' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearOwner() {
      owner = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'partitionNum' field */
    public java.lang.Integer getPartitionNum() {
      return partitionNum;
    }
    
    /** Sets the value of the 'partitionNum' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setPartitionNum(int value) {
      validate(fields()[3], value);
      this.partitionNum = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'partitionNum' field has been set */
    public boolean hasPartitionNum() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'partitionNum' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearPartitionNum() {
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'currentVersion' field */
    public java.lang.Integer getCurrentVersion() {
      return currentVersion;
    }
    
    /** Sets the value of the 'currentVersion' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setCurrentVersion(int value) {
      validate(fields()[4], value);
      this.currentVersion = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'currentVersion' field has been set */
    public boolean hasCurrentVersion() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'currentVersion' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearCurrentVersion() {
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'enableReads' field */
    public java.lang.Boolean getEnableReads() {
      return enableReads;
    }
    
    /** Sets the value of the 'enableReads' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setEnableReads(boolean value) {
      validate(fields()[5], value);
      this.enableReads = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'enableReads' field has been set */
    public boolean hasEnableReads() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'enableReads' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearEnableReads() {
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'enableWrites' field */
    public java.lang.Boolean getEnableWrites() {
      return enableWrites;
    }
    
    /** Sets the value of the 'enableWrites' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setEnableWrites(boolean value) {
      validate(fields()[6], value);
      this.enableWrites = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'enableWrites' field has been set */
    public boolean hasEnableWrites() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'enableWrites' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearEnableWrites() {
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'storageQuotaInByte' field */
    public java.lang.Long getStorageQuotaInByte() {
      return storageQuotaInByte;
    }
    
    /** Sets the value of the 'storageQuotaInByte' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setStorageQuotaInByte(long value) {
      validate(fields()[7], value);
      this.storageQuotaInByte = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'storageQuotaInByte' field has been set */
    public boolean hasStorageQuotaInByte() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'storageQuotaInByte' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearStorageQuotaInByte() {
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'readQuotaInCU' field */
    public java.lang.Long getReadQuotaInCU() {
      return readQuotaInCU;
    }
    
    /** Sets the value of the 'readQuotaInCU' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setReadQuotaInCU(long value) {
      validate(fields()[8], value);
      this.readQuotaInCU = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'readQuotaInCU' field has been set */
    public boolean hasReadQuotaInCU() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'readQuotaInCU' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearReadQuotaInCU() {
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'hybridStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord getHybridStoreConfig() {
      return hybridStoreConfig;
    }
    
    /** Sets the value of the 'hybridStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setHybridStoreConfig(com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord value) {
      validate(fields()[9], value);
      this.hybridStoreConfig = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'hybridStoreConfig' field has been set */
    public boolean hasHybridStoreConfig() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'hybridStoreConfig' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearHybridStoreConfig() {
      hybridStoreConfig = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'accessControlled' field */
    public java.lang.Boolean getAccessControlled() {
      return accessControlled;
    }
    
    /** Sets the value of the 'accessControlled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setAccessControlled(boolean value) {
      validate(fields()[10], value);
      this.accessControlled = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'accessControlled' field has been set */
    public boolean hasAccessControlled() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'accessControlled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearAccessControlled() {
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'compressionStrategy' field */
    public java.lang.Integer getCompressionStrategy() {
      return compressionStrategy;
    }
    
    /** Sets the value of the 'compressionStrategy' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setCompressionStrategy(int value) {
      validate(fields()[11], value);
      this.compressionStrategy = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'compressionStrategy' field has been set */
    public boolean hasCompressionStrategy() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'compressionStrategy' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearCompressionStrategy() {
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'chunkingEnabled' field */
    public java.lang.Boolean getChunkingEnabled() {
      return chunkingEnabled;
    }
    
    /** Sets the value of the 'chunkingEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setChunkingEnabled(boolean value) {
      validate(fields()[12], value);
      this.chunkingEnabled = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'chunkingEnabled' field has been set */
    public boolean hasChunkingEnabled() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'chunkingEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearChunkingEnabled() {
      fieldSetFlags()[12] = false;
      return this;
    }

    /** Gets the value of the 'singleGetRouterCacheEnabled' field */
    public java.lang.Boolean getSingleGetRouterCacheEnabled() {
      return singleGetRouterCacheEnabled;
    }
    
    /** Sets the value of the 'singleGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setSingleGetRouterCacheEnabled(boolean value) {
      validate(fields()[13], value);
      this.singleGetRouterCacheEnabled = value;
      fieldSetFlags()[13] = true;
      return this; 
    }
    
    /** Checks whether the 'singleGetRouterCacheEnabled' field has been set */
    public boolean hasSingleGetRouterCacheEnabled() {
      return fieldSetFlags()[13];
    }
    
    /** Clears the value of the 'singleGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearSingleGetRouterCacheEnabled() {
      fieldSetFlags()[13] = false;
      return this;
    }

    /** Gets the value of the 'batchGetRouterCacheEnabled' field */
    public java.lang.Boolean getBatchGetRouterCacheEnabled() {
      return batchGetRouterCacheEnabled;
    }
    
    /** Sets the value of the 'batchGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setBatchGetRouterCacheEnabled(boolean value) {
      validate(fields()[14], value);
      this.batchGetRouterCacheEnabled = value;
      fieldSetFlags()[14] = true;
      return this; 
    }
    
    /** Checks whether the 'batchGetRouterCacheEnabled' field has been set */
    public boolean hasBatchGetRouterCacheEnabled() {
      return fieldSetFlags()[14];
    }
    
    /** Clears the value of the 'batchGetRouterCacheEnabled' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearBatchGetRouterCacheEnabled() {
      fieldSetFlags()[14] = false;
      return this;
    }

    /** Gets the value of the 'batchGetLimit' field */
    public java.lang.Integer getBatchGetLimit() {
      return batchGetLimit;
    }
    
    /** Sets the value of the 'batchGetLimit' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setBatchGetLimit(int value) {
      validate(fields()[15], value);
      this.batchGetLimit = value;
      fieldSetFlags()[15] = true;
      return this; 
    }
    
    /** Checks whether the 'batchGetLimit' field has been set */
    public boolean hasBatchGetLimit() {
      return fieldSetFlags()[15];
    }
    
    /** Clears the value of the 'batchGetLimit' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearBatchGetLimit() {
      fieldSetFlags()[15] = false;
      return this;
    }

    /** Gets the value of the 'numVersionsToPreserve' field */
    public java.lang.Integer getNumVersionsToPreserve() {
      return numVersionsToPreserve;
    }
    
    /** Sets the value of the 'numVersionsToPreserve' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder setNumVersionsToPreserve(int value) {
      validate(fields()[16], value);
      this.numVersionsToPreserve = value;
      fieldSetFlags()[16] = true;
      return this; 
    }
    
    /** Checks whether the 'numVersionsToPreserve' field has been set */
    public boolean hasNumVersionsToPreserve() {
      return fieldSetFlags()[16];
    }
    
    /** Clears the value of the 'numVersionsToPreserve' field */
    public com.linkedin.venice.controller.kafka.protocol.admin.UpdateStore.Builder clearNumVersionsToPreserve() {
      fieldSetFlags()[16] = false;
      return this;
    }

    @Override
    public UpdateStore build() {
      try {
        UpdateStore record = new UpdateStore();
        record.clusterName = fieldSetFlags()[0] ? this.clusterName : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.storeName = fieldSetFlags()[1] ? this.storeName : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.owner = fieldSetFlags()[2] ? this.owner : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.partitionNum = fieldSetFlags()[3] ? this.partitionNum : (java.lang.Integer) defaultValue(fields()[3]);
        record.currentVersion = fieldSetFlags()[4] ? this.currentVersion : (java.lang.Integer) defaultValue(fields()[4]);
        record.enableReads = fieldSetFlags()[5] ? this.enableReads : (java.lang.Boolean) defaultValue(fields()[5]);
        record.enableWrites = fieldSetFlags()[6] ? this.enableWrites : (java.lang.Boolean) defaultValue(fields()[6]);
        record.storageQuotaInByte = fieldSetFlags()[7] ? this.storageQuotaInByte : (java.lang.Long) defaultValue(fields()[7]);
        record.readQuotaInCU = fieldSetFlags()[8] ? this.readQuotaInCU : (java.lang.Long) defaultValue(fields()[8]);
        record.hybridStoreConfig = fieldSetFlags()[9] ? this.hybridStoreConfig : (com.linkedin.venice.controller.kafka.protocol.admin.HybridStoreConfigRecord) defaultValue(fields()[9]);
        record.accessControlled = fieldSetFlags()[10] ? this.accessControlled : (java.lang.Boolean) defaultValue(fields()[10]);
        record.compressionStrategy = fieldSetFlags()[11] ? this.compressionStrategy : (java.lang.Integer) defaultValue(fields()[11]);
        record.chunkingEnabled = fieldSetFlags()[12] ? this.chunkingEnabled : (java.lang.Boolean) defaultValue(fields()[12]);
        record.singleGetRouterCacheEnabled = fieldSetFlags()[13] ? this.singleGetRouterCacheEnabled : (java.lang.Boolean) defaultValue(fields()[13]);
        record.batchGetRouterCacheEnabled = fieldSetFlags()[14] ? this.batchGetRouterCacheEnabled : (java.lang.Boolean) defaultValue(fields()[14]);
        record.batchGetLimit = fieldSetFlags()[15] ? this.batchGetLimit : (java.lang.Integer) defaultValue(fields()[15]);
        record.numVersionsToPreserve = fieldSetFlags()[16] ? this.numVersionsToPreserve : (java.lang.Integer) defaultValue(fields()[16]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
