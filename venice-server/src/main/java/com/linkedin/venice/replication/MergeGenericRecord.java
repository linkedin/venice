package com.linkedin.venice.replication;

import com.linkedin.venice.exceptions.VeniceException;
import com.linkedin.venice.exceptions.VeniceUnsupportedOperationException;
import java.util.List;
import org.apache.avro.Schema;
import org.apache.avro.generic.GenericRecord;

import static com.linkedin.venice.VeniceConstants.*;


/**
 * Implemnetions of the API defined in {@link Merge} based on V1 metadata timestamp Schema generated by
 * {@link com.linkedin.venice.schema.TimestampMetadataSchemaAdapterV1}.
 * All the implementations assume timestamp metadata format is union record type [long, record] where record
 * is top-level fieldName:timestamp format.
 * 1. Currently collection merging is not supported as TSMD does not support it yet.
 * 2. scehma evolution is not supported, so it assumes incoming and old schema are same else else throws VeniceException
 * 3. Assumes new value to be GenericRecord type, does not support non-record values.
 */
class MergeGenericRecord implements Merge<GenericRecord> {

  @Override
  public ValueAndTimestampMetadata<GenericRecord> put(ValueAndTimestampMetadata<GenericRecord> oldValueAndTimestampMetadata, GenericRecord newValue,
      long writeOperationTimestamp) {
    GenericRecord oldTimestampMetadata = oldValueAndTimestampMetadata.getTimestampMetadata();
    GenericRecord oldValue = oldValueAndTimestampMetadata.getValue();

    // TODO support schema evolution and caching the result of schema validation.
    if (oldValue != null && !oldValue.getSchema().equals(newValue.getSchema())) {
      throw new VeniceException("Incoming schema " + newValue.getSchema() + " is not same as existing schema" + oldValue.getSchema());
    }

    Object tsObject = oldTimestampMetadata.get(TIMESTAMP_FIELD);
    TSMDType tsmdType = getTSMDType(tsObject);

    switch (tsmdType) {
      case RECORDLEVEL_TS:
        long oldTimeStamp = (long) tsObject;
        if (oldTimeStamp < writeOperationTimestamp) {
          oldValueAndTimestampMetadata.setValue(newValue);
          oldTimestampMetadata.put(TIMESTAMP_FIELD, writeOperationTimestamp);
        } else if (oldTimeStamp == writeOperationTimestamp) {
          // for timestamp tie, if old value was null persist new value.
          if (oldValue == null) {
            oldValueAndTimestampMetadata.setValue(newValue);
          } else {
            // else let compare decide which one to store.
            oldValueAndTimestampMetadata.setValue((GenericRecord) compareAndReturn(oldValue, newValue));
          }
        }
        return oldValueAndTimestampMetadata;

      case PERFIELD_TS:
        GenericRecord timestampRecordForOldValue = (GenericRecord) tsObject;

        // TODO: Support schema evolution, as the following assumes old/new schema are same.
        oldValueAndTimestampMetadata.setValue(newValue);

        // update the field values based on TSMD
        List<Schema.Field> fields = timestampRecordForOldValue.getSchema().getFields();
        boolean allFieldsNew = true;
        for (int i = 0, fieldsSize = fields.size(); i < fieldsSize; i++) {
          Schema.Field field = fields.get(i);
          long fieldTimestamp = (long) timestampRecordForOldValue.get(field.pos());

          if (fieldTimestamp > writeOperationTimestamp) {
            newValue.put(field.name(), oldValue.get(field.pos()));
            allFieldsNew = false;
          } else if (fieldTimestamp == writeOperationTimestamp) {
            Object o1 = oldValue.get(field.name());
            Object o2 = newValue.get(field.name());

            // keep the old value in case of timestamp tie
            newValue.put(field.name(), compareAndReturn(o1, o2));
            allFieldsNew = false;
          } else {
            // update the timestamp since writeOperationTimestamp wins
            timestampRecordForOldValue.put(field.name(), writeOperationTimestamp);
          }
        }
        if (allFieldsNew) {
          oldTimestampMetadata.put(TIMESTAMP_FIELD, writeOperationTimestamp);
        }
        return oldValueAndTimestampMetadata;

      default:
        throw new VeniceException("Invalid TSMD type"  + tsmdType);
    }
  }

  @Override
  public ValueAndTimestampMetadata<GenericRecord> delete(ValueAndTimestampMetadata<GenericRecord> oldValueAndTimestampMetadata,
      long writeOperationTimestamp) {
    GenericRecord oldTimestampMetadata = oldValueAndTimestampMetadata.getTimestampMetadata();

    Object tsObject = oldTimestampMetadata.get(TIMESTAMP_FIELD);
    TSMDType tsmdType = getTSMDType(tsObject);

    switch (tsmdType) {
      case RECORDLEVEL_TS:
        long oldTimeStamp = (long)tsObject;
        // delete wins when old and new write operation timestamps are equal.
        if (oldTimeStamp <= writeOperationTimestamp) {
          oldValueAndTimestampMetadata.setValue(null);
          oldTimestampMetadata.put(TIMESTAMP_FIELD, writeOperationTimestamp);
        }
        return oldValueAndTimestampMetadata;

      case PERFIELD_TS:
        GenericRecord oldValue = oldValueAndTimestampMetadata.getValue();
        GenericRecord timestampRecord = (GenericRecord)tsObject;
        boolean newerField = false;

        List<Schema.Field> fields = timestampRecord.getSchema().getFields();
        for (int i = 0, fieldsSize = fields.size(); i < fieldsSize; i++) {
          Schema.Field field = fields.get(i);
          long fieldTimestamp = (long) timestampRecord.get(field.pos());
          if (fieldTimestamp <= writeOperationTimestamp) {
            oldValue.put(field.name(), oldValue.getSchema().getField(field.name()).defaultValue());
            timestampRecord.put(field.name(), writeOperationTimestamp);
          } else {
            newerField = true;
          }
        }
        // all fields are older than write timestamp, do full delete
        if (!newerField) {
          oldValueAndTimestampMetadata.setValue(null);
          // update the timestamp since writeOperationTimestamp wins
          oldTimestampMetadata.put(TIMESTAMP_FIELD, writeOperationTimestamp);
        }
        return oldValueAndTimestampMetadata;

      default:
        throw new VeniceException("Invalid TSMD type"  + tsmdType);
    }
  }

  @Override
  public ValueAndTimestampMetadata<GenericRecord> update(ValueAndTimestampMetadata<GenericRecord> oldValueAndTimestampMetadata,
      GenericRecord writeComputeRecord, long writeOperationTimestamp) {
    throw new VeniceUnsupportedOperationException("update operation not yet supported.");
  }

  private TSMDType getTSMDType(Object tsObject) {
    if (tsObject instanceof Long) {
      return TSMDType.RECORDLEVEL_TS;
    } else {
      return TSMDType.PERFIELD_TS;
    }
  }

  private Object compareAndReturn(Object o1, Object o2) {
    if (o1 == null) {
      return o2;
    } else if (o2 == null) {
      return o1;
    }
    if (o1.hashCode() >= o2.hashCode()) {
      return o1;
    } else {
      return o2;
    }
  }

  private enum TSMDType {
    RECORDLEVEL_TS(0), PERFIELD_TS(1);
    int val;
    TSMDType(int val) {
      this.val = val;
    }
  }
}
