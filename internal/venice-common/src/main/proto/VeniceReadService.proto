syntax = 'proto3';
package com.linkedin.venice.protocols;

option java_multiple_files = true;

service VeniceReadService {
  // Existing RPCs (implemented)
  rpc get (VeniceClientRequest) returns (VeniceServerResponse) {}
  rpc batchGet(VeniceClientRequest) returns (VeniceServerResponse) {}
  rpc countByValue(CountByValueRequest) returns (CountByValueResponse) {}

  // New RPCs below are defined for future implementation.
  // Server-side implementation will be added in subsequent PRs.

  rpc singleGet(SingleGetRequest) returns (SingleGetResponse) {}

  rpc multiGet(MultiGetRequest) returns (MultiKeyResponse) {}

  rpc multiGetStreaming(MultiGetRequest) returns (stream MultiKeyStreamingResponse) {}

  rpc compute(ComputeRequest) returns (MultiKeyResponse) {}

  rpc computeStreaming(ComputeRequest) returns (stream MultiKeyStreamingResponse) {}

  rpc isServerHealthy(HealthCheckRequest) returns (HealthCheckResponse) {}

  rpc getCompressionDictionary(CompressionDictionaryRequest) returns (CompressionDictionaryResponse) {}

  rpc handleAdminRequest(AdminRequest) returns (AdminResponse) {}

  rpc getMetadata(MetadataRequest) returns (MetadataResponse) {}

  rpc getCurrentVersionInfo(CurrentVersionInfoRequest) returns (CurrentVersionInfoResponse) {}

  rpc getIngestionContext(IngestionContextRequest) returns (IngestionContextResponse) {}
}

message VeniceClientRequest {
  uint32 partition = 1;
  string keyString = 2;           // used for single get
  bytes  keyBytes = 3;            // used for batch get
  string resourceName = 5;
  bool   isStreamingRequest = 7;
  bool   isRetryRequest = 8;
  bool   isBatchRequest = 9;

  string method = 10;
}

message VeniceServerResponse {
  sint32 schemaId = 1;
  bytes  data = 2;
  uint32 compressionStrategy = 3;
  uint32 responseRCU = 4;
  bool   isStreamingResponse = 5;

  uint32 errorCode = 6;
  string errorMessage = 7;
}

message CountByValueRequest {
  repeated bytes keys = 1;
  string resourceName = 2;
  int32 topK = 3;
  repeated string fieldNames = 4;
}

message CountByValueResponse {
  map<string, ValueCount> fieldToValueCounts = 1;
  uint32 errorCode = 2;
  string errorMessage = 3;
}

message ValueCount {
  map<string, int32> valueToCounts = 1;
}

/*
 * Note: The following message formats will be evolved in the future. The current format is used
 * for the initial implementation and helps refactor the existing code.
 */
message SingleGetRequest {
  string resourceName = 1;
  uint32 partition = 2;
  string key = 3;
  bool isRetryRequest = 4;
  string keyEncodingType = 5;
}

message SingleGetResponse {
  int32 statusCode = 1;
  bytes value = 2;
  sint32 schemaId = 3;
  uint32 compressionStrategy = 4;
  optional string errorMessage = 5;
  string contentType = 6;
  uint32 contentLength = 7;
  uint32 rcu = 8;
}

message MultiGetRequest {
  string resourceName = 1;
  bool isRetryRequest = 2;
  // keyCount allows pre-allocating buffers without iterating the repeated keys field.
  // Servers should validate keyCount == keys.size() if both are set.
  uint32 keyCount = 3;
  repeated MultiKeyRequestKey keys = 4;
  repeated RpcRequestHeader headers = 5;
}

message MultiKeyRequestKey {
  // Using int32 for consistency with MultiKeyStreamingResponse.keyIndex (sint32)
  int32 keyIndex = 1;
  uint32 partition = 2;
  bytes keyBytes = 3;
}

message ComputeRequest {
  string resourceName = 1;
  bytes computeRequestBytes = 2;
  sint32 computeValueSchemaId = 3;
  bool isRetryRequest = 4;
  uint32 apiVersion = 5;
  // keyCount allows pre-allocating buffers without iterating the repeated keys field.
  // Servers should validate keyCount == keys.size() if both are set.
  uint32 keyCount = 6;
  repeated MultiKeyRequestKey keys = 7;
  repeated RpcRequestHeader headers = 8;
}

message MultiKeyResponse {
  int32 statusCode = 1;
  bytes value = 2;
  sint32 schemaId = 3;
  uint32 compressionStrategy = 4;
  optional string errorMessage = 5;
  string contentType = 6;
  uint32 contentLength = 7;
  uint32 rcu = 8;
}

message MultiKeyStreamingResponse {
  int32 statusCode = 1;
  sint32 keyIndex = 2;
  bytes value = 3;
  sint32 schemaId = 4;
  uint32 compressionStrategy = 5;
  optional string errorMessage = 6;
  string contentType = 7;
  uint32 contentLength = 8;
  uint32 rcu = 9;
}

message RpcRequestHeader {
  string key = 1;
  string value = 2;
}

message HealthCheckRequest {
}

message HealthCheckResponse {
  int32 statusCode = 1;
  string message = 2;
}

message CompressionDictionaryRequest {
  string storeName = 1;
  uint32 storeVersion = 2;
}

message CompressionDictionaryResponse {
  int32 statusCode = 1;
  bytes value = 2;
  string contentType = 3;
  uint32 contentLength = 4;
  optional string errorMessage = 5;
}

// Enum corresponding to com.linkedin.venice.meta.ServerAdminAction.
// Values are offset by 1 from Java enum to accommodate proto3's required UNSPECIFIED = 0.
// Server must map: proto value - 1 = Java enum ordinal (when proto value > 0).
enum ServerAdminAction {
  SERVER_ADMIN_ACTION_UNSPECIFIED = 0;
  DUMP_INGESTION_STATE = 1;
  DUMP_SERVER_CONFIGS = 2;
}

message AdminRequest {
  string resourceName = 1;
  optional uint32 partition = 2;
  ServerAdminAction serverAdminAction = 3;
}

message AdminResponse {
  int32 statusCode = 1;
  bytes value = 2;
  sint32 schemaId = 3;
  string contentType = 4;
  uint32 contentLength = 5;
  optional string errorMessage = 6;
}

message CurrentVersionInfoRequest {
  string storeName = 1;
}

message CurrentVersionInfoResponse {
  int32 statusCode = 1;
  sint32 currentVersion = 2;
  optional string errorMessage = 3;
  string contentType = 4;
}

message MetadataRequest {
  string storeName = 1;
}

message MetadataResponse {
  int32 statusCode = 1;
  bytes value = 2;
  sint32 schemaId = 3;
  string contentType = 4;
  uint32 contentLength = 5;
  optional string errorMessage = 6;
}

message IngestionContextRequest {
  string versionTopicName = 1;
  string topicName = 2;
  uint32 partition = 3;
}

message IngestionContextResponse {
  int32 statusCode = 1;
  bytes value = 2;
  string contentType = 3;
  uint32 contentLength = 4;
  optional string errorMessage = 5;
}
