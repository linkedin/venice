package com.linkedin.alpini.netty4.handlers;

import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponse;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.handler.timeout.ReadTimeoutException;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;


/**
 * This handler closes the connection when a ReadTimeoutException occurs.
 *
 * Example:
 * <pre>
 * public class MyChannelInitializer extends {@link io.netty.channel.ChannelInitializer}&lt;{@link io.netty.channel.Channel}&gt; {
 *   public void initChannel({@link io.netty.channel.Channel} channel) {
 *     channel.pipeline().addLast("readTimeoutHandler", new {@link io.netty.handler.timeout.ReadTimeoutHandler}(30, TimeUnit.SECONDS);
 *     channel.pipeline().addLast("staleConnectionHandler", new {@link StaleConnectionHandler}());
 *   }
 * }
 * </pre>
 *
 * @author Antony T Curtis {@literal <acurtis@linkedin.com>}
 */
public class StaleConnectionHandler extends ChannelDuplexHandler {
  private static final Logger LOG = LogManager.getLogger(StaleConnectionHandler.class);

  /** @deprecated */
  private final long _closeConnectionTimeMillis;

  private final long _creationTimestamp = System.currentTimeMillis();

  private long _lastActivityTime = _creationTimestamp;
  private boolean _staleChannel;
  private boolean _lastResponse;
  private int _inFlight;

  /**
   * Create an EspressoIdleConnectionHandler which will close idle connections (detected by a separate IdleStateHandler added to the pipeline).
   */
  public StaleConnectionHandler() {
    assert !isSharable() : "Not sharable";
    _closeConnectionTimeMillis = Long.MAX_VALUE;
  }

  /**
   * Create an EspressoIdleConnectionHandler which will close idle connections (detected by a separate IdleStateHandler added to the pipeline),
   * and will close non-idle connections after a specified time.
   *
   * Connections will be closed at a random time between {@code minCloseAge} and {@code maxCloseAge}.
   *
   * @param minCloseAge base age of an active connection before we terminate
   * @param maxCloseAge random offset, should be large enough to spread out closing time for multiple connections
   * @param unit TimeUnit for closeAfterAgeBase and closeAfterAgeRandom
   */
  @Deprecated
  public StaleConnectionHandler(long minCloseAge, long maxCloseAge, TimeUnit unit) {
    assert !isSharable() : "Not sharable";
    // Calculate a semi-random time in the future to close this connection. Randomizing the time
    // ensures we don't close all client connections at the same instant.
    if (minCloseAge > maxCloseAge) {
      throw new IllegalArgumentException("minCloseAge must be <= maxCloseAge");
    }
    _closeConnectionTimeMillis = System.currentTimeMillis() + TimeUnit.MILLISECONDS.convert(minCloseAge, unit)
        + ThreadLocalRandom.current().nextInt((int) TimeUnit.MILLISECONDS.convert(maxCloseAge - minCloseAge, unit));
  }

  public boolean isStaleChannel() {
    return _staleChannel;
  }

  /**
   * Calls {@link ChannelHandlerContext#fireExceptionCaught(Throwable)} to forward
   * to the next {@link io.netty.channel.ChannelHandler} in the {@link io.netty.channel.ChannelPipeline}.
   * <p>
   * Sub-classes may override this method to change behavior.
   *
   * @param ctx
   * @param cause
   */
  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    if (cause instanceof ReadTimeoutException) {
      _staleChannel = true;
      // Close the channel when it has been idle. The IdleStateEvent is generated by a Netty IdleStateHandler
      // that must be added to the pipeline before this handler.
      long idleMillis = System.currentTimeMillis() - _lastActivityTime;
      if (_inFlight > 0) {
        LOG.info("No activity on active channel after {} ms", idleMillis);
        return;
      }
      // Close the channel when it has been idle. The IdleStateEvent is generated by a Netty IdleStateHandler
      // that must be added to the pipeline before this handler.
      ctx.channel().close();
      LOG.info(
          "Closing idle connection {} to remote address {} after {} millis of inactivity.",
          ctx.channel(),
          ctx.channel().remoteAddress(),
          idleMillis);
    } else {
      super.exceptionCaught(ctx, cause);
    }
  }

  @Override
  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
    // Close the channel when it is old by setting keep-alive to false. This only closes the channel if there is traffic
    // on the channel,
    // but if there is no traffic then the channel will just be closed by the idle handler.
    if (msg instanceof HttpResponse) {
      _inFlight--;
      if (_inFlight <= 0 && isStaleChannel()) {
        HttpUtil.setKeepAlive((HttpResponse) msg, false);
        _lastResponse = true;
      }
    }
    if (_lastResponse && msg instanceof LastHttpContent) {
      promise.addListener(ChannelFutureListener.CLOSE);
      LOG.info(
          "Closing active connection {} to remote address {} after {} millis.",
          ctx.channel(),
          ctx.channel().remoteAddress(),
          System.currentTimeMillis() - _creationTimestamp);
    }
    super.write(ctx, msg, promise);
  }

  @Override
  public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    _lastActivityTime = System.currentTimeMillis();
    if (msg instanceof HttpRequest) {
      _inFlight++;
    }
    super.channelRead(ctx, msg);
  }

  /** For unit tests, return the _closeConnectionTimeMillis calculated for this connection. */
  @Deprecated
  /* package private */ long getCloseConnectionTimeMillis() {
    return _closeConnectionTimeMillis;
  }
}
