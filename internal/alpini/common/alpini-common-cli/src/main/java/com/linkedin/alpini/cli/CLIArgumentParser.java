/*
 * $Id$
 */
package com.linkedin.alpini.cli;

import java.io.File;
import java.io.PrintWriter;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import javax.annotation.Nonnull;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.GnuParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.MissingOptionException;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;


/**
 * Utility class to handle typical command line argument parsing and log initialization. In addition to
 * parsing the command line, this class can display help information. All command lines will support the
 * "--help" argument, which will be handled automatically by CLIArgumentParser.
 *
 * To use this class, a command line application should define a public class with a public field for each
 * command line option. The options should be annotated as either a CLIArgument or a CLIFlag. CLIArgument is
 * used for options that expect some sort of argument, like a path or server hostname. CLIFlag is for boolean
 * flags that have no argument.
 *
 * Both annotations require an argument description which will be used when displaying command line usage. They
 * also allow a long option name (like "--server-address") and a short option name (like "-s"). If no long option is
 * given, it will be automatically generated from the member variable name. If no short option is given, the option
 * will have no short option.
 *
 * CLIArguments also require an argument name, and allow a default value. The argument name is displayed with
 * usage information. In the usage information "--infile <filename>", "filename" is the argument name. Default values
 * are used for optional fields. If a field does not have a default value provided, then it is required on the command
 * line. Otherwise, the default will be used.
 *
 * CLIFlags have no default value or argument name. They will be set to "true" if present on the command line;
 * false otherwise.
 *
 * Below is a sample class that shows how to use CLIArgumentParser. It declares an inner Args class with
 * one required argument "path" and three optional arguments.
 <pre>

  public class ExportTopology {
    public static class Args {
      &#64;CLIArgument(description="Path to topology files", argumentName="products")
      public String path;
      &#64;CLIArgument(description="Comma delimited list of fabrics to export", argumentName="products", defaultValue="all fabrics")
      public String fabrics;
      &#64;CLIArgument(description="Comma delimited list of products to export", argumentName="products", defaultValue="all products")
      public String products;
      &#64;CLIArgument(description="File to export to, in csv format", argumentName="filename", defaultValue="stdout")
      public String outfile;
    }

    public static void main(String[] args) {
      Args cliArgs = new CLIArgumentParser<Args>("ExportTopology", Args.class).startup(args);
      if (cliArgs == null) {
        // bad command line, exit.
        return;
      }
      // ...
    }
  }
 </pre>
 *
 * The usage information generated by this class is:
 <pre>
   usage: ExportTopology [--fabrics <products>] [--help] [--outfile <filename>] --path <products> [--products <products>]
    --fabrics <products>    Comma delimited list of fabrics to export(optional; default=all fabrics)
    --help                  Show usage information
    --outfile <filename>    File to export to, in csv format(optional; default=stdout)
    --path <products>       Path to topology files (required)
    --products <products>   Comma delimited list of products to export(optional; default=all products)
 </pre>
 *
 * @author Jemiah Westerman <jwesterman@linkedin.com>
 * @version $Revision$
 */
public class CLIArgumentParser<T> implements CLIParser<T> {
  private static final String[] ACCEPTED_DATE_FORMATS =
      { "MM/dd/yyyy hh:mm:ss:SSS", "MM/dd/yyyy", "MM/dd/yyyy hh:mm:ss:SSS zzz" };

  static final String NO_DEFAULT_STRING = "\0\0\0\0[NO DEFAULT]\0\0\0\0";
  static final char NO_DEFAULT_CHAR = 0x00;

  private static final Logger LOG = LogManager.getLogger(CLIArgumentParser.class);
  private final String _applicationName;

  private final Class<T> _class;
  private final Options _options;

  private PrintWriter _err = new PrintWriter(System.err, true);
  private PrintWriter _out = new PrintWriter(System.out, true);

  private static boolean isNotDefault(String argument) {
    return !NO_DEFAULT_STRING.equals(argument);
  }

  /**
   * Create a new parser for the given application and argument class. The argument class should have one or more
   * public fields, annotated with the CLIArgument or CLIOption annotation.
   *
   * @param applicationName name of the application, used in usage messages
   * @param klass class used for arguments
   */
  @SuppressWarnings("static-access")
  public CLIArgumentParser(String applicationName, Class<T> klass) {
    _applicationName = applicationName;
    _class = klass;
    _options = new Options();
    boolean unknown = false;
    StringBuilder desc = new StringBuilder();

    for (Field field: _class.getDeclaredFields()) {
      boolean handled = false;
      if (field.isAnnotationPresent(CLIArgument.class)) {
        CLIArgument arg = field.getAnnotation(CLIArgument.class);

        boolean noDefault = !isNotDefault(arg.defaultValue());
        desc.setLength(0);
        desc.append(arg.description());
        desc.append(arg.optional() ? " (optional" : noDefault ? " (required" : " (optional; default=");
        if (!arg.optional() && !noDefault) {
          desc.append(arg.defaultValue());
        }
        if (field.getType().isEnum()) {
          desc.append("; options=").append(Arrays.asList(field.getType().getEnumConstants()));
        }
        desc.append(")");

        String shortOpt = getShortOpt(arg.shortOpt());
        String longOpt = getLongOpt(arg.longOpt(), shortOpt, field);
        String argName = isNotDefault(arg.argumentName()) ? arg.argumentName() : field.getType().getSimpleName();

        Option.Builder builder = Option.builder(shortOpt)
            .longOpt(longOpt)
            .hasArg()
            .argName(argName)
            .desc(desc.toString())
            .required(!arg.optional() && noDefault);

        Option option = builder.build();

        _options.addOption(option);
        handled = true;
      }
      if (field.isAnnotationPresent(CLIFlag.class)) {
        if (handled) {
          throw new IllegalArgumentException("Multiple CLI annotations are not supported.");
        }

        // CLIOptions are flags, like "--exit-after-error". They must be boolean type.
        if (field.getType() != Boolean.class && field.getType() != boolean.class) {
          throw new IllegalArgumentException("CLIOption must be applied to boolean fields only.");
        }

        CLIFlag arg = field.getAnnotation(CLIFlag.class);
        String shortOpt = getShortOpt(arg.shortOpt());
        String longOpt = getLongOpt(arg.longOpt(), shortOpt, field);
        Option.Builder builder = Option.builder(shortOpt).longOpt(longOpt).desc(arg.description());

        Option option = builder.build();

        _options.addOption(option);
        handled = true;
      }
      if (field.isAnnotationPresent(CLIUnknown.class)) {
        if (handled) {
          throw new IllegalArgumentException("Multiple CLI annotations are not supported.");
        }
        if (unknown) {
          throw new IllegalArgumentException("CLIUnknown may only be applied to one field only.");
        }
        if (!field.getType().isAssignableFrom(String[].class)) {
          throw new IllegalArgumentException("CLIUnknown must be applied to String[] fields only.");
        }

        unknown = true;
        handled = true;
      }
      LOG.debug("field: {} handled={}", field, handled);
    }

    // Add the built in "help" argument
    _options.addOption(Option.builder().longOpt("help").desc("Show usage information").build());
  }

  /**
   * Parse the given command line. If the command line is legal, the options will
   * be printed to the log and returned. If the command line is invalid, it will display command line usage
   * and exit.
   * <p />
   * In addition, the startup method understands the "--help" argument. If
   * "--help" is given, startup will display usage information and return null.
   *
   * @param args command line arguments
   * @return parsed arguments; null if the command line was invalid
   */
  public T startup(String[] args) {
    T ret = parse(args);
    if (ret != null) {
      logConfiguredValues(ret);
    }
    return ret;
  }

  /**
   * Log the configured values. An application will typically not call this method, since this information is
   * logged automatically by the startup() method.
   *
   * @param args arguments to log
   * @see #startup(String[])
   */
  public void logConfiguredValues(T args) {
    try {
      for (Field field: _class.getDeclaredFields()) {
        if (field.isAnnotationPresent(CLIArgument.class)) {
          CLIArgument arg = field.getAnnotation(CLIArgument.class);
          String longOpt = isNotDefault(arg.longOpt()) ? arg.longOpt() : getLongArgName(field.getName());
          LOG.debug("{}={}", longOpt, field.get(args));
        } else if (field.isAnnotationPresent(CLIFlag.class)) {
          CLIFlag arg = field.getAnnotation(CLIFlag.class);
          String longOpt = isNotDefault(arg.longOpt()) ? arg.longOpt() : getLongArgName(field.getName());
          LOG.debug("{}={}", longOpt, field.get(args));
        }
      }
    } catch (IllegalArgumentException | IllegalAccessException ex) {
      throw new RuntimeException(ex);
    }
  }

  /**
   * Parse the given command line and return the arguments, or null if the arguments are invalid. An application
   * will typically not call this method, but will instead use startup(), which parses the command line and
   * logs the configured values.
   *
   * @param args arguments to parse
   * @return parsed arguments; null if the command line is invalid
   * @see #startup(String[])
   */
  @Override
  public T parse(String[] args) {
    try {
      T ret = _class.newInstance();

      // In spite of GnuParser being deprecated, the suggested replacement DefaultParser cannot handle all cases.
      CommandLineParser parser = new GnuParser() {
        @Override
        protected void checkRequiredOptions() throws MissingOptionException {
          // When "help" is found on the command line, we do not want to report failure because of missing options.
          if (!cmd.hasOption("help")) {
            super.checkRequiredOptions();
          }
        }
      };

      CommandLine line = parser.parse(_options, args);

      // Handle the built in "help" argument.
      if (line.hasOption("help")) {
        showUsage(true);
        return null;
      }

      for (Field field: _class.getDeclaredFields()) {
        if (field.isAnnotationPresent(CLIArgument.class)) {
          CLIArgument arg = field.getAnnotation(CLIArgument.class);
          String shortOpt = getShortOpt(arg.shortOpt());
          String longOpt = getLongOpt(arg.longOpt(), shortOpt, field);
          boolean hasDefault = isNotDefault(arg.defaultValue());

          String argValue = longOpt != null
              ? line.getOptionValue(longOpt, hasDefault ? arg.defaultValue() : null)
              : line.getOptionValue(arg.shortOpt(), hasDefault ? arg.defaultValue() : null);

          if (argValue == null) {
            continue;
          }

          if (field.getType() == Integer.class || field.getType() == int.class) {
            try {
              field.set(ret, Integer.valueOf(argValue));
            } catch (Exception ex) {
              showUsage("Bad value for " + field.getName() + ": \"" + argValue + "\". Value must be an integer (int)");
              return null;
            }
          } else if (field.getType() == Float.class || field.getType() == float.class) {
            try {
              field.set(ret, Float.valueOf(argValue));
            } catch (Exception ex) {
              showUsage(
                  "Bad value for " + field.getName() + ": \"" + argValue
                      + "\". Value must be a decimal number (float)");
              return null;
            }
          } else if (field.getType() == Long.class || field.getType() == long.class) {
            try {
              field.set(ret, Long.valueOf(argValue));
            } catch (Exception ex) {
              showUsage(
                  "Bad value for " + field.getName() + ": \"" + argValue + "\". Value must be a long integer (long)");
              return null;
            }
          } else if (field.getType() == Double.class || field.getType() == double.class) {
            try {
              field.set(ret, Double.valueOf(argValue));
            } catch (Exception ex) {
              showUsage(
                  "Bad value for " + field.getName() + ": \"" + argValue
                      + "\". Value must be a decimal number (double)");
              return null;
            }
          } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {
            try {
              field.set(ret, Boolean.valueOf(argValue));
            } catch (Exception ex) {
              showUsage("Bad value for " + field.getName() + ": \"" + argValue + "\". Legal values are [true, false]");
              return null;
            }
          } else if (field.getType() == Date.class) {
            boolean success = false;
            for (String fmt: ACCEPTED_DATE_FORMATS) {
              try {
                Date date = new SimpleDateFormat(fmt, Locale.ENGLISH).parse(argValue);
                field.set(ret, date);
                success = true;
                break;
              } catch (java.text.ParseException ex) {
                // Attempt next format
              }
            }

            if (!success) {
              try {
                Date d = new Date(Long.parseLong(argValue));
                field.set(ret, d);
              } catch (NumberFormatException e) {
                showUsage(
                    "Bad value for " + field.getName() + ": \"" + argValue
                        + "\". Value must be a time in ms or a date string of following forms: "
                        + Arrays.asList(ACCEPTED_DATE_FORMATS));
                return null;
              }
            }
          } else if (field.getType() == File.class) {
            field.set(ret, new File(argValue));
          } else if (field.getType() == URI.class) {
            try {
              field.set(ret, new URI(argValue));
            } catch (URISyntaxException e) {
              showUsage("Bad value for " + field.getName() + ": \"" + argValue + "\". Value must be a valid URI");
              return null;
            }
          } else if (field.getType() == String.class) {
            field.set(ret, argValue);
          } else if (field.getType().isEnum()) {
            try {
              // Handle enums
              Class<?> k = field.getType();
              Method m = k.getMethod("valueOf", String.class);
              Object value = m.invoke(null, argValue);
              field.set(ret, value);
            } catch (Throwable ex) {
              showUsage(
                  "Bad value for " + field.getName() + ": \"" + argValue + "\". Legal values are "
                      + Arrays.asList(field.getType().getEnumConstants()) + ".");
              return null;
            }
          } else {
            try {
              // Handle ENUMs that were implemented with "public static final ". Specifically, log4j log levels...
              Field f = field.getType().getField(argValue);
              Object value = f.get(null);
              field.set(ret, value);
            } catch (Exception ex) {
              // Build a list of all "public static final " constants in the class for the usage string.
              List<String> legalConstantNames = new ArrayList<>();
              for (Field f: field.getType().getFields()) {
                if (f.getType() == field.getType() && Modifier.isPublic(f.getModifiers())
                    && Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
                  legalConstantNames.add(f.getName());
                }
              }
              showUsage(
                  "Bad value for " + field.getName() + ": \"" + argValue + "\". Legal values are " + legalConstantNames
                      + ".");
              return null;
            }
          }
        } else if (field.isAnnotationPresent(CLIFlag.class)) {
          CLIFlag arg = field.getAnnotation(CLIFlag.class);
          String shortOpt = getShortOpt(arg.shortOpt());
          String longOpt = getLongOpt(arg.longOpt(), shortOpt, field);

          if (longOpt != null ? line.hasOption(longOpt) : line.hasOption(arg.shortOpt())) {
            field.set(ret, Boolean.TRUE);
          } else {
            field.set(ret, Boolean.FALSE);
          }
        } else if (field.isAnnotationPresent(CLIUnknown.class)) {
          field.set(ret, line.getArgs());
        }
      }

      return ret;
    } catch (IllegalAccessException | InstantiationException ex) {
      throw new RuntimeException(ex);
    } catch (ParseException ex) {
      // Bad command line.
      showUsage("Bad command line: " + ex.getMessage());
      return null;
    }
  }

  public CLIArgumentParser<T> redirect(@Nonnull PrintWriter out, @Nonnull PrintWriter err) {
    _out = out;
    _err = err;
    return this;
  }

  /**
   * Display command line usage information. This is invoked automatically by startup() if the --help
   * argument is present.
   */
  @Override
  public void showUsage(boolean verbose) {
    String header = "";
    String footer = "";
    if (_class.isAnnotationPresent(CLIHeader.class)) {
      CLIHeader annotation = _class.getAnnotation(CLIHeader.class);
      header = annotation.value();
    }
    if (_class.isAnnotationPresent(CLIFooter.class)) {
      CLIFooter annotation = _class.getAnnotation(CLIFooter.class);
      footer = annotation.value();
    }

    int columns = HelpFormatter.DEFAULT_WIDTH;
    try {
      String txt = System.getenv("COLUMNS");
      columns = Math.max(Integer.parseInt(txt, 10), columns);
    } catch (Throwable ignored) {
    }

    HelpFormatter formatter = new HelpFormatter();

    if (verbose) {
      formatter.printHelp(
          _out,
          columns,
          _applicationName,
          header,
          _options,
          formatter.getLeftPadding(),
          formatter.getDescPadding(),
          footer,
          true);
    } else {
      formatter.printUsage(new PrintWriter(new Writer() {
        @Override
        public void write(@Nonnull char[] cbuf, int off, int len) {
          _out.print(Arrays.copyOfRange(cbuf, off, len));
        }

        @Override
        public void flush() {
          _out.flush();
        }

        @Override
        public void close() {
          // does nothing;
        }
      }, true), columns, _applicationName, _options);
    }
  }

  /**
   * Display an error message plus command line usage information. This is invoked automatically by startup()
   * if the command line is invalid.
   */
  public void showUsage(String error) {
    _err.println(error);
    showUsage(false);
  }

  private static String getShortOpt(char shortOpt) {
    return shortOpt != NO_DEFAULT_CHAR ? String.valueOf(shortOpt) : null;
  }

  private static String getLongOpt(String longOpt, String shortOpt, Field field) {
    return isNotDefault(longOpt) ? longOpt : shortOpt == null ? getLongArgName(field.getName()) : null;
  }

  private static String getLongArgName(String fieldName) {
    StringBuilder sb = new StringBuilder();
    int pos = 0;
    // Strip leading _
    if (fieldName.startsWith("_")) {
      pos++;
    }
    sb.append(Character.toLowerCase(fieldName.charAt(pos++)));
    for (; pos < fieldName.length(); pos++) {
      char ch = fieldName.charAt(pos);
      // put a dash wherever case changes. This seems to make the most sense for arguments like
      // URIPrefix -> uri-prefix or targetQPS -> target-qps
      if (Character.isUpperCase(ch) && !Character.isUpperCase(fieldName.charAt(pos - 1))) {
        sb.append('-');
      }
      sb.append(Character.toLowerCase(ch));
    }
    return sb.toString();
  }
}
