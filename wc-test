#!/usr/bin/env python3

import os
import re
import json
import time
import shlex
import random
import argparse
import textwrap
import subprocess
import urllib.parse

CI_CONFIG = ".ciconfig"

def get_config(path):
  if not os.path.isfile(path):
    path = os.path.expanduser(os.path.join('~', path))
    if not os.path.isfile(path):
      return {}
  with open(path) as file:
    config = json.load(file)
    return config

def run_command(command):
  status, output = subprocess.getstatusoutput(command)
  if status:
    raise SystemExit(output)
  return output

def get_queued_build(build_url, params):
  while True:
    response = run_command("curl --http1.1 -fs '{0}api/json' -u $(whoami):{apiToken}"
      .format(build_url, **params))
    build = json.loads(response)
    if ("executable" in build) or build["blocked"] or build["buildable"]:
      return build
    time.sleep(1)

if __name__ == "__main__":
  class HelpFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):
    pass

  parser = argparse.ArgumentParser(
    formatter_class=HelpFormatter,
    argument_default=argparse.SUPPRESS,
    description=textwrap.dedent(
      """
      Test current working copy on Jenkins.

      Please follow instructions from the link below to generate an API token:
      https://jenkins.io/doc/book/system-administration/authenticating-scripted-clients

      Example ~/{config}:
      {{
        \"url\": \"https://venice-ci.stg.linkedin.com:8443\",
        \"apiToken\": \"**********************************\"
      }}
      """.format(config=CI_CONFIG)))

  parser.add_argument("-j", "--job", help="jenkins job to run")
  parser.add_argument("-b", "--baseline", help="baseline branch/tag to use for testing")
  parser.add_argument("-m", "--message", help="optional description of the changes")
  parser.add_argument("patch", nargs='?', help="diff-formatted patch to submit for testing")

  params = dict(job="Venice-WcTest", baseline="origin/master", message="")
  params.update(get_config(CI_CONFIG))
  parser.set_defaults(**params)
  params.update(vars(parser.parse_args()))

  if isinstance(params["url"], list):
    params["url"] = random.choice(params["url"])

  if "patch" not in params and not params["message"]:
    params["message"] = run_command("git log --format=%s -1 HEAD")

  template = "curl --http1.1 -fv '{url}/job/{job}/buildWithParameters?{params}' -u $(whoami):{apiToken} -F patch.diff=@{{0}}" \
    .format(**params, params=urllib.parse.urlencode(dict(baseline=params["baseline"], message=params["message"])))

  if "patch" in params:
    response = run_command(template.format(shlex.quote(params["patch"])))
  else:
    changes = run_command("git diff --find-renames --compact-summary {baseline}".format(**params))
    if not changes:
      raise SystemExit("No changes")

    revision = '#' + run_command("git rev-parse --short HEAD")
    response = run_command(
      "git diff --patch --find-renames --compact-summary {baseline} |".format(**params) + template.format("-;filename=" + revision))

    print("Submitted working copy {name} for testing:".format(name=revision))
    print(changes)
    print()

  build_url = re.findall("< Location: (https?://.+)", response)[0]
  build = get_queued_build(build_url, params)
  if build.get("cancelled"):
    print("Build cancelled")
  elif build["blocked"] or build["buildable"]:
    print(build["task"]["url"])
  else:
    print(build["executable"]["url"])
